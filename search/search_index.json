{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"# Industrial Informatics  *Course material for the second part and Lab sesions of the Industrial Informatics course at [the University of M\u00e1laga](https://www.uma.es).*   By [Juan M. Gandarias](https://jmgandarias.com)   Systems Engineering and Automation Department  [Find out more...](./about/README.md)"},{"location":"about/","title":"Welcome","text":""},{"location":"about/#welcome","title":"Welcome","text":"<p>This is the home of the Industrial Informatics course: A fourth-year undergraduate course for Electronics Engineering students in the School of Industrial Engineering at the University of M\u00e1laga. The lab course is developed by Dr Juan M. Gandarias, an Assistant Professor in the Systems Engineering and Automation Department.</p>"},{"location":"about/#course-content","title":"Course content","text":"<ul> <li>Intro to microcontrollers programming</li> <li>Real-Time in Embedded Systems</li> <li>Human-Machine Interfaces</li> <li>Internet of Things with MQTT</li> </ul>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>The delivery of these materials following this format has been inspired by the work done by Dr. Tom Howard in the COM2009-3009 Robotics Course at The University of Sheffield. In addition, the content presented has been inspired by various sources listed below.</p>"},{"location":"about/acknowledgements/#mqtt","title":"MQTT","text":"<ul> <li>Luis LLamas Tutorials.</li> <li>R. Buyya y A. V. Dastjerdi, Internet of Things: Principles and paradigms. Elsevier, 2016.</li> <li>K. Ashton et al., \u201cThat \u2018internet of things\u2019 thing,\u201d RFID journal, vol. 22, n.o 7, p\u00e1gs. 97-114, 2009.</li> <li>Fremantle et al., \u201cA reference architecture for the internet of things,\u201d WSO2 White paper, p\u00e1gs. 02-04, 2015.</li> <li>Y. Zhang y F. Tao, Optimization of manufacturing systems using the Internet of Things. Academic Press, 2016.</li> <li>M. Schwartz, Internet of Things with ESP8266. Packt Publishing Ltd, 2016.</li> <li>T. Pulver, Hands-On Internet of Things with MQTT: Build connected IoT devices with Arduino and MQ Telemetry Transport (MQTT). Packt Publishing Ltd, 2019.</li> <li>L. R. Kanagachidambaresan, Internet of Things Using Single Board Computers: Principles of IoT and Python Programming. Springer, 2022.</li> </ul>"},{"location":"about/changelog/","title":"Version History","text":""},{"location":"about/changelog/#iteration-1","title":"Iteration 1","text":"<p>Academic Year: 2024-2025</p> <ul> <li>Initial release of the material.</li> <li>Included MQTT material only (for now...).</li> </ul>"},{"location":"about/license/","title":"License","text":"<p> This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. </p> <p>You are free to distribute, remix, adapt, and build upon this work (for non-commercial purposes only) as long as credit is given to the original author.</p> <p>For more information, check this link.</p>"},{"location":"hmi/","title":"MQTT","text":""},{"location":"hmi/#mqtt","title":"MQTT","text":"<ul> <li> <p>Getting Started: \"A hands-on introduction to MQTT\".</p> <p>Here you will start working with MQTT.</p> </li> <li> <p>Exercise 1:: \"MQTT with ESP32 in wokwi\".</p> <p>In this exercise you will learn how to develop an IoT application based on MQTT that allows you to publish and subscribe to topics with an ESP32 in simulation from Wokwi.</p> </li> <li> <p>Exercise 2:: \"MQTT with ESP32 in the real world\".</p> <p>Example of MQTT application with a real ESP32.</p> </li> <li> <p>Lab Session:: \"MQTT with M5Core2\".</p> <p>MQTT Lab Exercise with the M5 Core 2 device.</p> </li> </ul>"},{"location":"intro/","title":"Introduction","text":""},{"location":"intro/#introduction-to-microcontrollers-programming","title":"Introduction to microcontrollers programming","text":"<ul> <li> <p>Getting started: An introduction to the course.</p> <p>This page summarizes the prerequisites of the course</p> </li> <li> <p>Lab Session 0: Microcontrollers simulation with Wokwi.</p> <p>In this exercise you will learn how to simulate microcontrollers with Wokwi.</p> </li> <li> <p>Lab Session 1: Intro to microcontrollers programming.</p> <p>Here, you will explore the fundamentals of programming microcontrollers.</p> </li> </ul>"},{"location":"intro/getting_started/","title":"Getting Started","text":""},{"location":"intro/getting_started/#getting-started","title":"Getting Started","text":""},{"location":"intro/getting_started/#1-what-is-a-microcontroller","title":"1. What is a Microcontroller?","text":"<p>A microcontroller is a compact integrated circuit designed to perform specific tasks within an embedded system. Unlike general-purpose computers, microcontrollers are optimized for controlling devices, sensors, and actuators in real-time applications. Key characteristics:</p> <ul> <li>Low power consumption</li> <li>Real-time processing capabilities</li> <li>Integration of CPU, memory, and peripherals on a single chip</li> </ul> <p>Microcontrollers are widely used in automation, robotics, IoT devices, and industrial control systems.</p>"},{"location":"intro/getting_started/#2-course-hardware-and-tools","title":"2. Course Hardware and Tools","text":"<p>In this course, we will use the following components and tools:</p>"},{"location":"intro/getting_started/#21-esp32-microcontroller","title":"2.1. ESP32 Microcontroller","text":"<p>The ESP32 is a powerful and versatile microcontroller featuring:</p> <ul> <li>Dual-core processor</li> <li>Built-in Wi-Fi and Bluetooth</li> <li>Multiple GPIO pins for sensors and actuators</li> <li>Support for various communication protocols (I2C, SPI, UART)</li> </ul>"},{"location":"intro/getting_started/#22-wokwi-simulator","title":"2.2. Wokwi Simulator","text":"<p>Wokwi is an online simulator that allows you to:</p> <ul> <li>Prototype circuits without physical hardware</li> <li>Test and debug Arduino, ESP32, and other microcontrollers projects</li> <li>Visualize sensor and actuator behavior in simulated real-time</li> </ul>"},{"location":"intro/getting_started/#23-arduino-ide","title":"2.3. Arduino IDE","text":"<p>The Arduino Integrated Development Environment (IDE) will be our main programming tool. It provides:</p> <ul> <li>A simple interface for writing and uploading code</li> <li>Extensive libraries for sensors, displays, and communication</li> <li>Cross-platform compatibility (Windows, macOS, Linux)</li> </ul>"},{"location":"intro/getting_started/#24-m5core2-development-kit","title":"2.4. M5Core2 Development Kit","text":"<p>The M5Core2 is an ESP32-based device with:</p> <ul> <li>A touchscreen display</li> <li>Built-in sensors and expansion ports</li> <li>A modular design for rapid prototyping</li> </ul>"},{"location":"intro/lab0/","title":"Lab Session 0: Microcontrollers simulation with Wokwi","text":""},{"location":"intro/lab0/#lab-session-0-microcontrollers-simulation-with-wokwi","title":"Lab Session 0: Microcontrollers simulation with Wokwi","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"intro/lab0/#1-launch-an-example","title":"1. Launch an example","text":"<ul> <li>Access the Wokwi simulation environment via this link.</li> <li> <p>Select the ESP32 template.</p> <p> </p> <p>Warning</p> <p>Open the ESP32 template from <code>Starter Templates</code>, not from <code>ESP-IDF Templates</code>. The former is based on the Arduino IDE while the latter is based on the ESP-IDF environment that will not be used in the course.</p> </li> <li> <p>Connect an LED to <code>GPIO 21</code> with a resistor, as shown in the diagram (rotate - R and flip - P components if necessary).</p> <p></p> </li> <li> <p>Simulate the following sketch:</p> <pre><code>#define LED_PIN 21\n#define BUTTON_PIN 35\n\nvoid setup() {\n    pinMode(LED_PIN, OUTPUT);\n    pinMode(BUTTON_PIN, INPUT_PULLUP);\n}\n\nvoid loop() {\n    digitalWrite(LED_PIN, HIGH);\n    delay(500);\n    digitalWrite(LED_PIN, LOW);\n    delay(500);\n}\n</code></pre> <p>Question</p> <ul> <li>What is the purpose of the <code>setup()</code> function?</li> <li>What is the purpose of the <code>loop()</code> function?</li> <li>What does the <code>#define</code> do?</li> <li>What does the <code>pinMode()</code> function do?</li> <li>What does the <code>digitalWrite()</code> function do?</li> <li>What does the <code>delay()</code> function do?</li> </ul> </li> </ul>"},{"location":"intro/lab0/#2-control-the-led-state-with-a-push-button","title":"2. Control the LED state with a push button","text":"<ul> <li> <p>Implement the circuit shown in the following diagram and simulate a program that:</p> <ul> <li>Turns the LED ON when the button is pressed.</li> <li>Turns the LED OFF when the button is not pressed.</li> </ul> <p>Tip</p> <ul> <li>Use the function <code>digitalRead()</code> to get the status of the button.</li> <li>You may need to use the <code>if...else</code> condition.</li> </ul> <p></p> <p>Warning</p> <p>When you place the button, don\u2019t forget to deselect the bounce option to avoid bouncing issues. </p> <p>Question</p> <ul> <li>What information is included in the <code>diagram.json</code>? Did it change with respect to the previous exercise?  </li> <li>Can you do the exercise without using the <code>if...else</code> condition? How?</li> </ul> </li> </ul>"},{"location":"intro/lab0/#3-additional-exercises","title":"3. Additional exercises","text":""},{"location":"intro/lab0/#31-blink","title":"3.1. Blink","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED while the button is pushed.</p> <p>Tip</p> <p>You may need to use the <code>millis()</code> function.</p> </li> </ul>"},{"location":"intro/lab0/#32-short-press-vs-long-press","title":"3.2. Short press vs long press","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that does the following:</p> <ul> <li>Short press (&lt; 500 ms): Toggle LED (if the LED is ON, turns it OFF, and viceversa).</li> <li>Long press (\u2265 500 ms): Blink LED.</li> </ul> <p>Tip</p> <p>You may need to use the <code>millis()</code> function, and the  <code>if...else</code> condition.</p> </li> </ul>"},{"location":"intro/lab1/","title":"Lab Session 1: Intro to microcontrollers programming","text":""},{"location":"intro/lab1/#lab-session-1-intro-to-microcontrollers-programming","title":"Lab Session 1: Intro to microcontrollers programming","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"intro/lab1/#1-prepare-the-arduino-ide","title":"1. Prepare the Arduino IDE","text":"<p>Follow the installation steps described in this guide.</p> <ol> <li>Install Arduino IDE: Download it from this link.</li> <li> <p>Install the M5Stack board family:</p> <p></p> <p>You need to copy/paste this text to download the board package</p> <pre><code>https://static-cdn.m5stack.com/resource/arduino/package_m5stack_index.json \n</code></pre> <p></p> <p>Once the board package address is set, you can install it from the boards manager. </p> <p>Info</p> <p>This process may take a few minutes.</p> <p>Once installed, you can select M5Core2 from the board selection menu.</p> <p></p> </li> <li> <p>Install the Arduino libraries for M5Core2:</p> <p></p> <p>Warning</p> <p>When you press Install, you'll see the list of dependencies. You MUST install all the dependencies too. </p> <p>Info</p> <p>This is a long process that may take several minutes. Be patient...</p> <p>Tip</p> <p>In case the list of dependencies is that large that you cannot see the Install All button, you can press the tab key Tab twice to put the cursor over the button and then press Enter to install all the dependencies </p> </li> <li> <p>Install the CP2104 driver (USB driver):</p> <p>Download it from this link if you're using Windows, from this link if you're using MacOS, or from this other link if you're using Linux.</p> <p>More info about USB driver installation here.</p> <p>Now, when you connect the M5Core2 devide to the PC with the USB cable, you can select the port in the Arduino IDE.</p> <p></p> <p>Info</p> <ul> <li>In windows, the port is called COMX, where X is a number that can vary from time to time, e.g., COM5.</li> <li>In linux, the port is called \"ttyUSBX\" or \"ttyACMX\", where X is a number that can vary from time to time, e.g., ttyUSB2.</li> </ul> </li> <li> <p>Compile and upload the <code>hello_world.ino</code> example from M5Core2 library:</p> <p></p> <p>You can press the Upload (in red) button to compile and load the program to the device. Note that the button on the left (Verify - in green) compiles the program but doesn't upload it to the device.</p> <p></p> </li> <li> <p>OPTIONAL (do it ONLY if you have finished all the exercises of the lab session): You can open other examples if you want to see the potential of M5Core2. You can try this one:</p> <p></p> </li> </ol> <p>Additional resources</p> <p>Here you can find more documentation about some of the basic functions of M5Core2.  </p> <p>Pinout and Important Notes Below is the M5Core2 pinout. The pins marked in red are the ones we will use in the exercises.</p> <p></p> <p>Warning</p> <ul> <li>Some pins on the M5Core2 are preconfigured, so pay attention when connecting external components.</li> <li>The ESP32 inside the M5Core2 has 3 serial ports:<ul> <li><code>Serial1</code> is reserved for the display (do not use it).</li> <li><code>Serial0</code> can be configured (pins G3 \u2013 RXD0 and G1 \u2013 TXD0), but it is reserved for USB connection to the PC.</li> <li><code>Serial2</code> is free and can be configured (pins G13 \u2013 RXD2 and G14 \u2013 TXD2) as regular GPIO using pinMode().</li> </ul> </li> </ul>"},{"location":"intro/lab1/#2-turn-an-led-on-and-off","title":"2. Turn an LED ON and OFF","text":"<p>Connect an LED as follows:</p> <p></p> <p>Run the following program: </p><pre><code>#include &lt;M5Core2.h&gt;\n#define LED_PIN 14\n\nvoid setup() {\n  M5.begin(); // Initialize M5Core2\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(LED_PIN, HIGH);\n  delay(500);\n  digitalWrite(LED_PIN, LOW);\n  delay(500);\n}\n</code></pre> <p>Question</p> <p>Note that you had to include the <code>#include &lt;M5Core2.h&gt;</code> and the <code>M5.begin(); // Initialize M5Core</code> Why did you have to do that? what are these instructions for?</p>"},{"location":"intro/lab1/#3-additional-exercises","title":"3. Additional exercises","text":""},{"location":"intro/lab1/#31-blink-at-a-certain-frequency","title":"3.1. Blink at a certain frequency","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED at a frequency of 10Hz.</p> <p>Question</p> <ul> <li>For how long does the LED has to be ON or OFF in each cycle?</li> </ul> </li> </ul>"},{"location":"intro/lab1/#32-blink-and-stop","title":"3.2. Blink and stop","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED at a frequency of 2Hz and stops the blinking after 5 seconds.</p> <p>Question</p> <ul> <li>How many times does the LED blink?</li> <li>What is the final state of the LED when the blink stops, does it remain ON or OFF?</li> </ul> <p>Tip</p> <p>You may need to use the <code>for</code> loop, or the  <code>if...else</code> condition.</p> </li> </ul>"},{"location":"mqtt/","title":"MQTT","text":""},{"location":"mqtt/#mqtt","title":"MQTT","text":"<ul> <li> <p>Getting Started: \"A hands-on introduction to MQTT\".</p> <p>Here you will start working with MQTT.</p> </li> <li> <p>Exercise 1:: \"MQTT with ESP32 in wokwi\".</p> <p>In this exercise you will learn how to develop an IoT application based on MQTT that allows you to publish and subscribe to topics with an ESP32 in simulation from Wokwi.</p> </li> <li> <p>Exercise 2:: \"MQTT with ESP32 in the real world\".</p> <p>Example of MQTT application with a real ESP32.</p> </li> <li> <p>Lab Session:: \"MQTT with M5Core2\".</p> <p>MQTT Lab Exercise with the M5 Core 2 device.</p> </li> </ul>"},{"location":"mqtt/exercise1/","title":"Exercise 1: MQTT with ESP32 in wokwi","text":"<p>This section from the Industrial Informatics Course provides a practical guide to understanding and implementing MQTT with an ESP32 in simulation</p>"},{"location":"mqtt/exercise1/#contents","title":"Contents","text":"<ul> <li> <p>1. Connect to a network via WiFi</p> <ul> <li>How to connect the device to a network.</li> </ul> </li> <li> <p>2. Create a client and connect to a MQTT broker</p> <ul> <li>How to create an ESP32 client and connect it to a MQTT broker.</li> </ul> </li> <li> <p>3. Create a publisher</p> <ul> <li>How to publish messages to a topic with an ESP32 client.</li> </ul> </li> <li> <p>4. Create a subscriber</p> <ul> <li>How to subscribe to a topic to receive messages with an ESP32 client.</li> </ul> </li> <li> <p>5. Exercise: practical application</p> <ul> <li>A simple practical exercise to put practice the knowledge acquired in this part of the course.</li> </ul> </li> </ul> <p>This guide is designed to help learners set up and operate an MQTT broker, forming the foundation for efficient message exchange between IoT devices.</p>"},{"location":"mqtt/exercise1/part1_connect_wifi/","title":"1. Connect to a network via WiFi","text":"<p>In order to develop an IoT application using MQTT with an ESP32, the first thing we need to do is to connect the device to a network. Although this can be done in several ways, the most convenient way is to do it to a WiFi network. </p> <p>Let's do it in Wokwi!</p> <p>Warning</p> <p>As we are working in wokwi remotely, the ESP32 will have to connect to a wifi network accessible from the wokwi servers (i.e., you cannot connect the device to your WiFi network). Wokwi simulates a WiFi network with full internet access and provides a virtual WiFi access point called Wokwi-GUEST. It is an open access point - no password is required. For more info about network access in wokwi, check this link.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> wifi_connect.ino<pre><code>#include &lt;WiFi.h&gt; // (1)!\n\n#define WIFI_SSID \"Wokwi-GUEST\" // (2)!\n#define WIFI_PASSWORD \"\" // (3)!\n#define WIFI_CHANNEL 6 // (4)!\n\nvoid ConnectWiFi() // (5)!\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL); // (6)!\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED) // (7)!\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid setup(void) \n{\n  Serial.begin(115200);\n  ConnectWiFi(); // (8)!\n}\n\nvoid loop()\n{\n  delay(10); // (9)!\n}\n</code></pre> <ol> <li>The ESP32 WiFi library is based on the Arduino WiFi library and enables network connection (local and Internet) via WiFi.</li> <li>Here we define the name of the wifi network to which we want the device to connect. If you want to use the ESP32 in the real world, you need to enter the name of your local network</li> <li>Introduce the password of the network</li> <li>This is required in wokwi only. According to the documentation: We specify the WiFi channel number (6) when calling WiFi.begin(). This skips the WiFi scanning phase and saves about 4 seconds when connecting to the WiFi.</li> <li>This function is used to connect to the WiFi network (you can reuse it in your projects).</li> <li>This method initializes the WiFi library's network settings. If you don't want to use WIFI_CHANNEL (i,e., in real world project), you can delete the third argument of the function.    </li> <li>Wait until the device has connected to the network, when it's connected, it will display it through the serial port.</li> <li>The function <code>ConnectWiFi()</code> is called from the <code>setup()</code> so that the device connects to the network at the beginning of the program.</li> <li>This scripts doesn't do anything else, so there's nothing inside the <code>loop()</code>. Don't forget the <code>delay(10)</code> to speed up the simulation in wokwi (this is not needed in real world applications)</li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to connect an ESP32 to a WiFi network</p>"},{"location":"mqtt/exercise1/part2_client_connect/","title":"2. Create a client and connect to a MQTT broker","text":"<p>Let's extend the code from the previous entry and connect the ESP32 to a broker. </p> <p>Info</p> <p>The ESP32 is a simulated device in wokwi, so you won't be able to use your own broker (see 1. Install Mosquitto) unless you have allowed access to your network over the internet (this wasn't explained in thi course). Hence, let's use use a third party broker: the broker test.mosquitto.org. </p> <p>Public MQTT Broker</p> <p>Be aware that you're going to use a third party broker which is completely open. This implies that, first, you should not share relevant or sensitive information through that broker and use it only to test your MQTT application.</p> <p>Client and Topic names</p> <p>This broker is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_connect.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt; // (1)!\n#include &lt;PubSubClient.h&gt; // (2)!\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"test.mosquitto.org\"; // (3)!\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test\"; // (4)!\n\nWiFiClient espClient; // (5)!\nPubSubClient mqttClient(espClient); // (6)!\n\nvoid ConnectWiFi() // (7)!\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt() // (8)!\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT); \n}\n\nvoid ConnectMqtt() // (9)!\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\"try again in 5 seconds\");\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt() // (10)!\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt(); // (11)!\n}\n\nvoid loop()\n{\n  HandleMqtt(); // (12)!\n  delay(10);\n}\n</code></pre> <ol> <li>WiFiClient allows the creation of a client that can connect to to a specified internet IP address and port. In this case, you will use it to create a client connected to the test.mosquitto.org broker (server).</li> <li>PubSubClient allows a client for doing simple publish/subscribe messaging with a server that supports MQTT.</li> <li>You need to specify the broker address (test.mosquitto.org). If you want to use it with another broker, you need to specify the IP of the broker here (e.g., 192.168.0.12). You need to specify the broker port (by default, 1883 in MQTT).  NOTE THE * !!</li> <li>You need to specify the client name. Don't use a generic name, this name is the one that will be use the broker and other devices of the MQTT network. NOTE THE * !!</li> <li>Create the client. This name is not the client name in the network, but the name of the object in the script. I.e., you can choose the name freely as it won't be seen by anyone. </li> <li>Create the MQTT client.</li> <li>This functions is the same as the one in connect_wifi.</li> <li>This function initializes the client in the MQTT broker (you need to specify the IP address and port of the broker=server). I know there's only one line of code inside the function, it's been done on purpose. You'll see the reason in subscriber.</li> <li>This function connects the client to the broker. If the client isn't connected, it will try to connect every 5 seconds. If the client connects, it'l display it through the serial port.</li> <li>This function handles the connection to the broker. If the connection is lost, it calls the <code>ConnectMqtt()</code> function. If the client is connected, it uses the <code>mqtt.loop()</code> to check for new messages.</li> <li>The function <code>InitMqtt()</code> is called in the <code>setup()</code>.</li> <li>The funcion <code>HandleMqtt()</code> is called in the loop to keep the client connected and constantly check for new messages.</li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> <p>Cannot connect to broker</p> <p>It is possible that you've found problems when connecting to the broker <code>test.mosquitto.org</code>. Keep in mind that this server is public and is used by thousands of people simultaneously, so sometimes it doesn't work properly. Alternatively, you can use other free public brokers (e.g., the one used in the image above: <code>mqtt.eclipseprojects.io</code>).</p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to connect a MQTT client with an ESP32 and connect it to a broker</p>"},{"location":"mqtt/exercise1/part3_publisher/","title":"3. Create a publisher","text":"<p>Let's give some action to our MQTT application. This entry shows how you can create a publisher with an ESP32 in wokwi that can send messages to your PC. </p> <p>Client and Topic names</p> <p>You're going to use a public broker that is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_publisher.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_pub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload; // (1)!\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  // Wait for connection\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.print(\"Client connected\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid PublishMqtt(unsigned long data) // (2)!\n{\n  payload = \"\";\n  payload = String(data);\n  mqttClient.publish(\"/running_time\", (char *)payload.c_str());\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop()\n{\n  HandleMqtt();\n\n  PublishMqtt(millis()); // (3)!\n  Serial.println(millis()); \n\n  delay(1000);\n}\n</code></pre> <ol> <li>The client will publish messages to a topic using the method  <code>publish()</code> from the <code>PubSubClient.h</code> library. Checking the code of that method you will see it publishes <code>char</code> data. Remember the difference between <code>char</code> and <code>String</code>: In C++, the sequence of characters can be stored in two ways: either as a <code>std::string</code> (<code>String</code> in Arduino) object or <code>char array</code>. The latter is an array that contains single characters terminated by a null character, while the former creates an object that is used to represent strings in C++ and contain many methods to help in string manipulation. Since it's easier to manipulate <code>String</code>data than <code>char</code> data, we will use the <code>String</code> object <code>payload</code> to store the message that will be publish. This message, however, will need to be casted to a <code>char</code>before being published with <code>publish()</code> (explained later in the code). </li> <li>This function is used to publish <code>data</code> in a specific topic. It receives the <code>data</code> as a parameter (in this case <code>data</code> is an <code>unsigned long</code> variable, but it could have been something else, e.g., a <code>boolean</code>, or a <code>float</code>). The content of data need to be casted into <code>String</code>: here's when you use the <code>payload</code> variable. Then, the content of <code>payload</code> need to be casted into <code>char</code> according to the specifications of the method <code>publish()</code>. This is done with <code>(char *)payload.c_str()</code>.</li> <li>The function <code>PublishMqtt()</code> is called in the loop every 1s. The running time in milliseconds is given as a parameter to that function, meaning that will be the message to be published. </li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> <p>Info</p> <p>By checking the topic in MQTT Explorer you can see the time in milliseconds it takes for the ESP32 to publish the message and print over the serial port: 4 ms (it has to run the code inside <code>PublishMqtt()</code>, which also runs the method <code>publish()</code>).</p> </li> <li> <p>Subscribe to the topic in your terminal </p> <p>Run the following command in the terminal and you'll see that the ESP32 is communicating with your PC via MQTT as shwon in the image below </p><pre><code>mosquitto_sub -h mqtt.eclipseprojects.io -t /running_time\n</code></pre> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to publish messages to a MQTT topic with an ESP32.</p>"},{"location":"mqtt/exercise1/part4_subscriber/","title":"4. Create a subscriber","text":"<p>This entry shows how you can create a subscriber with an ESP32 in wokwi that can subscribe to topics. </p> <p>Client and Topic names</p> <p>You're going to use a public broker that is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_subscriber.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_sub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload;\nString content = \"\"; // (1)!\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n  SuscribeMqtt(); // (2)!\n  mqttClient.setCallback(OnMqttReceived); // (3)!\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n      SuscribeMqtt(); // (4)!\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid SuscribeMqtt() // (5)!\n{\n  mqttClient.subscribe(\"/testing_topic\");\n}\n\nvoid OnMqttReceived(char *topic, byte *payload, unsigned int length) // (6)!\n{\n  Serial.print(\"Received on \");\n  Serial.print(topic);\n  Serial.print(\": \");\n\n  content = \"\"; \n  for (size_t i = 0; i &lt; length; i++) // (7)!\n  {\n    content.concat((char)payload[i]);\n  }\n  Serial.print(content);\n  Serial.println();\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop() // (8)!\n{\n  HandleMqtt();\n  delay(10);\n}\n</code></pre> <ol> <li>As the message received in the topic will be a <code>char</code>, you'll use this variable to convert it to <code>String</code> for easier manipulation.</li> <li>Now, after setting the server, we need to call the function <code>SubscribeMqtt()</code>. This functions establishes the topics to which the client will be subscribed. This operation is a function for two reasons: <ol> <li>If the client is disconnected, it needs to subscribe to the topics again. So the function can be called multiple times in the code.</li> <li>If there is (or could be in the future) more than one topics to subscribe to, it can be easily addressed by simply modifying the code inside this function.</li> </ol> </li> <li>We need to set the function (callback) that will be called everytime a message is received. This function has been named <code>OnMqttReceived</code>.</li> <li><code>SubscribeMqtt()</code> is called again if the connection to the broker is lost.</li> <li><code>SubscribeMqtt()</code> defines the topics to which the client will subscribe. In this case, it will only subscribe to the topic <code>/testing_topic</code>, but there could be more than one inside the function. The client is subscribed to a topic using the method  <code>subscribe()</code> from the <code>PubSubClient.h</code> library. </li> <li>This function is a callback that will be called everytime a message is published in any of the topics that the client is subscribed to (similar to an interruption). Inside the callback, you get access to the <code>topic</code> where the message was published, the content of the message throught the variable <code>payload</code>, and the <code>length</code> of that message. </li> <li>The content of <code>payload</code> will be casted into <code>String</code>. In this case, <code>payload</code> is an array of bytes. These <code>bytes</code> need to be first casted into characters and then concatenated to form the final <code>String</code>. To do this, we first need to go through all the positions of the array (i.e., we use a <code>for</code> loop). This loop will go from the first element (<code>i=0</code>) to the last one (<code>i=length</code>). In every step of the loop, we first cast the element <code>i</code> of the array <code>payload</code> to <code>char</code>: <code>(char)payload[i]</code>. The data of this element should be concatenated to the string of <code>content</code> to form the final message. To do that we can use the method <code>concat()</code>. When the loop finishes, the <code>content</code> of the message is displayed through the serial port.</li> <li>This client works as a subscriber only. It means it won't do anything until a message is received. Hence, there's nothing inside the <code>loop()</code> (apart from the <code>HandleMqtt()</code> funcion that was explained in a previous entry).  </li> </ol> </li> <li> <p>If you have done it correctly, you should see that the ESP32 prints the content of the messages received in the topic <code>/testing_topic</code>. You can test it from the MQTT Explorer or the terminal.</p> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to subscribe to a MQTT topic with an ESP32.</p>"},{"location":"mqtt/exercise1/part5_exercise/","title":"5. Exercise: practical application","text":"<p>An exercise is proposed to communicate two ESP32s in an MQTT netword. One of them acts as publisher while the other as subscriber. The one that has the role of publisher has a button connected and, when the button is pressed (or released), it publishes in a topic that the button has been pressed. The other ESP32 will have a LED connected and will subscribe to the topic in which the ESP32 publisher publishes. Then, each time it receives a message in the topic, it changes the state of the LED.</p> <p>To test the application you can open two tabs in the browser and check that it works as follows:</p> <p></p> <p>Try to solve the problem before seeing the solution below.</p> Show publisher diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": -124.8,\n      \"left\": -187.16,\n      \"attrs\": {}\n    },\n    {\n      \"type\": \"wokwi-pushbutton\",\n      \"id\": \"btn1\",\n      \"top\": -3.4,\n      \"left\": -326.4,\n      \"attrs\": { \"color\": \"green\", \"bounce\": \"0\" }\n    }\n  ],\n  \"connections\": [\n    [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n    [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ],\n    [ \"btn1:1.r\", \"esp:14\", \"green\", [ \"v0\" ] ],\n    [ \"btn1:2.r\", \"esp:GND.1\", \"black\", [ \"h0\" ] ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> Show publisher code mqtt_publisher_button.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n# define BUTTON_PIN 14\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_pub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload; \n\nvolatile bool button_released = false;\n\n\nvoid IRAM_ATTR buttonReleased(){\n  button_released = true;\n}\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.print(\"Client connected\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid PublishMqtt(bool data) \n{\n  payload = \"\";\n  payload = String(data);\n  mqttClient.publish(\"/button_released\", (char *)payload.c_str());\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt((BUTTON_PIN)), buttonReleased, FALLING);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop()\n{\n  HandleMqtt();\n\n  if (button_released){\n    PublishMqtt(true);\n    Serial.println(\"Publishing button data\");\n    button_released = false;\n  }\n\n  delay(10);\n}\n</code></pre> Show subscriber diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juanma Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    { \"type\": \"board-esp32-devkit-c-v4\", \"id\": \"esp\", \"top\": -38.4, \"left\": -158.36, \"attrs\": {} },\n    {\n      \"type\": \"wokwi-led\",\n      \"id\": \"led1\",\n      \"top\": -42,\n      \"left\": -274.6,\n      \"attrs\": { \"color\": \"green\" }\n    },\n    {\n      \"type\": \"wokwi-resistor\",\n      \"id\": \"r1\",\n      \"top\": 41.8,\n      \"left\": -288.85,\n      \"rotate\": 270,\n      \"attrs\": { \"value\": \"1000\" }\n    }\n  ],\n  \"connections\": [\n    [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n    [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ],\n    [ \"led1:C\", \"r1:2\", \"black\", [ \"v0\" ] ],\n    [ \"r1:1\", \"esp:GND.1\", \"black\", [ \"v38.4\", \"h105.45\" ] ],\n    [ \"led1:A\", \"esp:26\", \"green\", [ \"v0\" ] ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> Show subscriber code mqtt_subscriber_LED.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define LED_PIN 26       \n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_sub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload;\nString content = \"\"; \n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n  SuscribeMqtt(); \n  mqttClient.setCallback(OnMqttReceived); \n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n      SuscribeMqtt(); \n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid SuscribeMqtt() \n{\n  mqttClient.subscribe(\"/button_released\");\n}\n\nvoid OnMqttReceived(char *topic, byte *payload, unsigned int length) \n{\n  Serial.print(\"Received on \");\n  Serial.print(topic);\n  Serial.print(\": \");\n\n  content = \"\"; \n  for (size_t i = 0; i &lt; length; i++) \n  {\n    content.concat((char)payload[i]);\n  }\n\n  Serial.print(content);\n  Serial.println();\n\n  digitalWrite(LED_PIN, !digitalRead(LED_PIN));\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  pinMode(LED_PIN, OUTPUT);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop() \n{\n  HandleMqtt();\n  delay(10);\n}\n</code></pre>"},{"location":"mqtt/exercise2/","title":"Exercise #2: MQTT with ESP32 in real world","text":"<p>TBD</p>"},{"location":"mqtt/getting_started/","title":"Getting Started: A hands-on introduction to MQTT","text":"<p>This section from the Industrial Informatics Course provides a practical guide to understanding and implementing MQTT (Message Queuing Telemetry Transport), a lightweight messaging protocol widely used in IoT (Internet of Things) applications.</p>"},{"location":"mqtt/getting_started/#contents","title":"Contents","text":"<ul> <li> <p>1. Install Mosquitto</p> <ul> <li>Step-by-step instructions for installing Mosquitto, an open-source MQTT broker, on your system.</li> </ul> </li> <li> <p>2. Testing Mosquitto from the terminal</p> <ul> <li>Guidance on testing the Mosquitto installation using terminal commands to verify its proper operation.</li> </ul> </li> <li> <p>3. Allow External Connections</p> <ul> <li>Steps to configure Mosquitto to accept external client connections, enabling communication over a network.</li> </ul> </li> </ul> <p>This guide is designed to help learners set up and operate an MQTT broker, forming the foundation for efficient message exchange between IoT devices.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/","title":"1. Install Mosquitto","text":""},{"location":"mqtt/getting_started/part1_install_mosquitto/#introduction","title":"Introduction","text":"<p>Eclipse Mosquitto is an Open Source Broker from the Eclipse Foundation distributed under EPL/EDL license that implements MQTT protocol. It is lightweight and is suitable for use on all devices from low power single board computers to full servers. It is programmed in C and is compatible with most OS. The code can be found in this repo.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#installation","title":"Installation","text":"<p>To install Mosquitto, you can follow the next steps.</p> <p>Info</p> <p>\"The steps below outline the Mosquitto installation process for Windows. If you are using Ubuntu, the installation process is much easier. You can find the steps for Ubuntu installation here. </p> <ol> <li>Download the installer from the official website. Check the corresponding type of your processor architecture (most probably 64-bit). Once you have the <code>.exe</code>, execute it to start the installation process.</li> <li>During the installation, install all the components.</li> </ol> <p></p> <ol> <li>When the installer asks you for the Destination Folder, leave the default one (most probably: <code>C:\\Program Files\\mosquitto</code>).</li> </ol> <p></p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#start-mosquitto","title":"Start Mosquitto","text":"<p>Now, you can start mosquitto through windows services. You can open the services by clicking the Win button and typing <code>Services</code>.  Here you can check the multiple ways to open windows services.</p> <p></p> <p>Once you have find the mosquito broker service, you can click on Start the service to start and enable the port where the mosquito will start listening for requests.</p> <p></p> <p>Info</p> <p>It may happen that when you open the windows services, mosquitto is already running.</p> <p>You can check in the terminal (Win <code>cmd</code>) if the service is active and the port enabled with the following command.</p> <pre><code>netstat -an\n</code></pre> <p></p> <p>Then you will see a list of enabling ports. Port 1883 is the one used by mosquitto for communication.</p> <p></p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#firewall","title":"Firewall","text":"<p>As mosquitto requires external communication, it is necessary to enable the windows firewall for incoming and outgoing requests on port 1883 (this way, the firewall does not block the mosquitto service).</p> <p>You need to go to <code>Control panel &gt; Windows defender firewall</code>. Then, go yo <code>advanced setting</code>.</p> <p></p> <p>It will open the Advanced Configuration of Firewall window where you have to look for inbound rules and click on new rule.</p> <ol> <li>The first step is to select the type of rule. In this case it is a port, so select it and click on next.</li> <li>Then, you select the rule for <code>tcp</code> and we write the corresponding port: <code>1883</code>. Click on <code>next</code> and allow all the connections.</li> <li>Apply the rule to all the network profiles and place a name to identify it. Click on finish and the rule will be created.</li> </ol> <p>Now you can create the outbound rule. Click on outbound rule and do the same steps you did before.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#path-environment-variable","title":"Path Environment Variable","text":"<p>Once you have Mosquitto running as a service and the firewall is correctly configured, you need to configure the environment variable.</p> <p>Info</p> <p>This is not strictly required but highly recommended. If you don't do this, you can only run Mosquitto commands in the terminal from the root installation folder <code>C:\\Program Files\\mosquitto</code>. If you add this folder to the Path, then you'll be able to run those commands from any location on your system. </p> <p>You need to acced the <code>environment variables</code> and search for the variable path to place the route <code>Control Panel &gt; System and security &gt; System</code>. </p> <p></p> <p>Then, open the advanced system configuration and click on <code>environment variables</code>.</p> <p></p> <p>Include the path where mosquitto was installed (remember step 3 of installation<code>C:\\Program Files\\mosquitto</code>). </p> <p></p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/","title":"2. Testing Mosquitto from the terminal","text":""},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#testing","title":"Testing","text":"<p>If you have already completed Part 1, now you can test mosquitto broker in your local machine. Open one terminal (Win + <code>cmd</code>) and go to the route where mosquitto was installed</p> <pre><code>cd C:\\Program Files\\mosquitto\n</code></pre> <p>Info</p> <p>If you have already configured the variable path in Part 1, the previous step should not be necessary.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#creating-a-subscriber","title":"Creating a subscriber","text":"<p>This terminal will act as a subscriber and will receive the messages published in the topic <code>/test</code>. To do so, run the following command</p> <pre><code>mosquitto_sub -h localhost -t /test\n</code></pre> <ol> <li> <p><code>mosquitto_sub</code> </p> <ul> <li>This is the Mosquitto client tool used to subscribe to an MQTT topic.</li> <li>It listens for messages published to specific topics.</li> </ul> </li> <li> <p><code>-h localhost</code> </p> <ul> <li><code>-h</code> specifies the host or broker address to connect to.</li> <li><code>localhost</code> means the broker is running on the same machine where the command is being executed. If the broker is on a remote server, you'd need to replace    <code>localhost</code> with the server's IP address or domain name.</li> </ul> </li> <li> <p><code>-t /test</code> </p> <ul> <li><code>-t</code> specifies the topic to subscribe to.</li> <li><code>/test</code> is the topic name in this example. Topics are hierarchical strings used by MQTT brokers to route messages. In this case, the client will subscribe to the <code>/test</code> topic and receive any messages published to it.</li> </ul> </li> </ol>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#explanation","title":"Explanation:","text":"<p>The command subscribes to the MQTT topic <code>/test</code> on a broker running locally (at <code>localhost</code>). Messages sent to the <code>/test</code> topic by other MQTT clients or publishers will be received and displayed by this subscriber.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#creating-a-publisher","title":"Creating a publisher","text":"<p>Without closing that terminal, open another one (Win + <code>cmd</code>). This second terminal will act as a publisher that will publish the message This is a testing message: Hello, MQTT! in the topic <code>/test</code>. This message will be received by the subscriber and will display it in the terminal</p> <pre><code>mosquitto_pub -h localhost -t /test -m \"This is a testing message: Hello, MQTT!\"\n</code></pre> <ol> <li> <p><code>mosquitto_pub</code> </p> <ul> <li>This is the Mosquitto client tool used to publish messages to an MQTT topic.</li> <li>It sends messages to the specified topic on the broker.</li> </ul> </li> <li> <p><code>-h localhost</code> </p> <ul> <li><code>-h</code> specifies the host or broker address to connect to.</li> <li><code>localhost</code> means the broker is running on the same machine where the command is being executed. If the broker is on a remote server, you'd replace <code>localhost</code> with the server's IP address or domain name.</li> </ul> </li> <li> <p><code>-t test</code> </p> <ul> <li><code>-t</code> specifies the topic to which the message will be published.</li> <li><code>test</code> is the topic name in this example. Other MQTT clients subscribed to this topic will receive the message.</li> </ul> </li> <li> <p><code>-m \"This is a testing message: Hello, MQTT!\"</code> </p> <ul> <li><code>-m</code> specifies the message to publish.</li> <li><code>\"This is a testing message: Hello, MQTT!\"</code> is the message content being sent to the <code>test</code> topic. Clients subscribed to the topic will see this exact message.</li> </ul> </li> </ol>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#explanation_1","title":"Explanation:","text":"<p>The command publishes the message <code>\"This is a testing message: Hello, MQTT!\"</code> to the MQTT topic <code>test</code> on a broker running locally (at <code>localhost</code>). Any MQTT clients subscribed to the <code>test</code> topic will receive this message.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#expected-result","title":"Expected result","text":"<p>If you have correctly done all the steps, you should have seen the following:</p> <p></p> <p>Note</p> <p>The subscriber will keep running indefinitely, waiting for messages. On the other hand, the publisher runs only once to send a single message. If you want to send more messages, you will need to re-run the entire command each time</p>"},{"location":"mqtt/getting_started/part3_external_connections/","title":"3. Allow External Connections","text":"<p>Connection from an external network</p> <p>This section allows you to connect external devices within a local network to the broker that you have created in Part1. When this section talks about IP address, it refers to the private IP address (i.e., the one assigned by the router that creates the network and that is only accessible by the devices that are on the network). If you want to work with devices outside the network, you need to work with the public IP address (which is unique and visible to everyone). If you would like to configure a broker to allow connections through the internet from external networks, you would have to configure port forwarding on the router (similarly to what you did in Part1 with the windows firewall). This could pose several security risks and would require taking precautions such as using TLS/SSL Encryption or a MQTT Proxy. This is out of the scope of this course, so it will not be explained here.</p>"},{"location":"mqtt/getting_started/part3_external_connections/#1-allow-external-connections","title":"1. Allow External Connections","text":"<p>By default, Mosquitto listens only on <code>localhost</code>. To allow external connections:</p> <ol> <li> <p>Open the Mosquitto configuration file (<code>mosquitto.conf</code>). The file is typically located in:</p> <ul> <li>Linux: <code>/etc/mosquitto/mosquitto.conf</code></li> <li>Windows: Wherever you installed Mosquitto, e.g., <code>C:\\Program Files\\mosquitto\\mosquitto.conf</code></li> </ul> </li> <li> <p>Add or edit the following line to bind Mosquitto to all network interfaces:     </p><pre><code>listener 1883\n</code></pre> <p></p> <ul> <li><code>1883</code> is the default MQTT port. If you want a custom port, specify it here.</li> <li>To restrict it to a specific IP, replace <code>listener 1883</code> with <code>listener 1883 &lt;IP Address&gt;</code>.</li> </ul> </li> <li> <p>Restart the Mosquitto service for changes to take effect:</p> <ul> <li>Linux:     <pre><code>sudo systemctl restart mosquitto\n</code></pre></li> <li>Windows: Restart Mosquitto from the Windows Services </li> </ul> </li> </ol> <p>Warning</p> <p>To edit a file inside <code>C:\\Program Files\\mosquitto\\</code>, you'll need administrator rights. To change the <code>mosquitto.conf</code>file, you can open it with VSCode (or any other text editor, e.g., notepad or gedit) if you open it as administrator.</p> <p></p>"},{"location":"mqtt/getting_started/part3_external_connections/#2-enable-username-and-password-authentication","title":"2. Enable Username and Password Authentication","text":"<ol> <li> <p>Create a password file:  </p> <ul> <li> <p>Linux:</p> <p>Use the <code>mosquitto_passwd</code> utility to generate the password file: </p><pre><code>mosquitto_passwd -c /etc/mosquitto/password &lt;username&gt;\n</code></pre> Replace <code>&lt;username&gt;</code> with your desired username. You will be prompted to enter a password. <p>Example: </p><pre><code>mosquitto_passwd -c /etc/mosquitto/password user1\n</code></pre> <code>-c</code> creates a new password file. If you want to add more users later, use: <pre><code>mosquitto_passwd /etc/mosquitto/password &lt;new-username&gt;\n</code></pre> </li> <li> <p>Windows:</p> <p>Use the <code>mosquitto_passwd</code> utility to generate the password file: </p><pre><code>mosquitto_passwd -c C:\\Program Files\\mosquitto\\password &lt;username&gt;\n</code></pre> Replace <code>&lt;username&gt;</code> with your desired username. You will be prompted to enter a password.  <p>Warning</p> <p>To edit a file inside <code>C:\\Program Files\\mosquitto\\</code>, you'll need administrator rights. If you run the previous command, you'll write in the <code>C:\\Program Files\\mosquitto\\password</code> file. To do so, you can open the terminal as administrator.</p> <p></p> <p>Example: </p><pre><code>mosquitto_passwd -c C:\\Program Files\\mosquitto\\password user1\n</code></pre> <p></p> <p><code>-c</code> creates a new password file. If you want to add more users later, use:</p> <pre><code>mosquitto_passwd C:\\Program Files\\mosquitto\\password &lt;new-username&gt;\n</code></pre> </li> </ul> </li> <li> <p>Update the configuration file to use the password file:</p> <ul> <li> <p>Linux:</p> <p>Open <code>mosquitto.conf</code> and add or edit the following lines: </p><pre><code>allow_anonymous false\npassword_file /etc/mosquitto/passwords\n</code></pre> </li> <li> <p>Windows:</p> <p>Open <code>mosquitto.conf</code> and add or edit the following lines: </p><pre><code>allow_anonymous false\npassword_file C:\\Program Files\\mosquitto\\password\n</code></pre> </li> </ul> <p></p> </li> <li> <p>Restart the Mosquitto service:</p> <ul> <li>Linux:     <pre><code>sudo systemctl restart mosquitto\n</code></pre></li> <li>Windows: Restart as mentioned earlier.</li> </ul> </li> </ol> <p>Warning</p> <p>If you receive this error when you try to restart the Mosquitto service</p> <p></p> <p>you must change the permissions of the <code>password</code> file. </p> <ul> <li>Find the password file in <code>C:/Program Files/mosquitto</code>, right click &gt; properties and go to the security tab. </li> </ul> <p>Check if the SYSTEM group has permissions to modify the file. If it does not, you will have to give them as follows. </p> <ul> <li>Click on Edit and then on Add.  </li> </ul> <p></p> <ul> <li>Add the group SYSTEM and give it permissions to modify the file and click on apply (this is very important).</li> </ul> <p></p> <p>The result should look like this</p> <p></p>"},{"location":"mqtt/getting_started/part3_external_connections/#3-firewall-rules","title":"3. Firewall Rules","text":"<p>If Mosquitto is running on a remote machine, make sure the firewall allows connections to the MQTT port (1883 by default).</p> <ul> <li> <p>Linux (using UFW):     </p><pre><code>sudo ufw allow 1883\n</code></pre> </li> <li> <p>Windows: Open \"Windows Defender Firewall,\" and allow inbound traffic for port 1883.</p> </li> </ul> <p>Note</p> <p>This was already done in Part 1</p>"},{"location":"mqtt/getting_started/part3_external_connections/#4-testing-external-access","title":"4. Testing External Access","text":""},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-a-generic-mqtt-client-mqtt-explorer","title":"Testing from a generic MQTT Client (MQTT Explorer)","text":"<p>You can test the connection from a generic MQTT Client like MQTT Explorer.</p> <ol> <li>Install MQTT Explorer.</li> <li> <p>Check the IP of the broker. Open a terminal and run</p> <ul> <li> <p>Linux </p><pre><code>ipconfig\n</code></pre> </li> <li> <p>Windows:      </p><pre><code>ifconfig\n</code></pre> </li> </ul> <p></p> <p>You need to annotate the IPv4 address. In my case: <code>192.168.0.12</code></p> </li> <li> <p>Launch MQTT Explorer and fill the IP, user and password</p> <p></p> </li> <li> <p>Publish in a topic from MQTT Explorer</p> <p></p> </li> </ol>"},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-another-pc","title":"Testing from another PC","text":"<p>You can test the connection from another PC in the network that has installed mosquitto too:</p> <ol> <li> <p>Subscribe from the broker device:     </p><pre><code>mosquitto_sub -h &lt;server-ip&gt; -t test -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> <li> <p>Publish from an external device:     </p><pre><code>mosquitto_pub -h &lt;server-ip&gt; -t test -m \"This is a message from an external device: Hello, MQTT!\" -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> </ol> <p>Replace <code>&lt;server-ip&gt;</code> with the server's IP address, <code>&lt;username&gt;</code> with your chosen username, and <code>&lt;password&gt;</code> with the associated password.</p>"},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-an-smartphone","title":"Testing from an Smartphone","text":"<p>You can test the connection from a Smartphone in the network that has installed mosquitto too:</p> <ol> <li>Install MyMQTT</li> <li> <p>Connect to the broker</p> <p></p> </li> <li> <p>Subscribe to topic <code>/test</code> and go to the Dashboard</p> <p></p> </li> <li> <p>Publish a message in <code>/test</code>from another device in the newtork (e.g., from a terminal in your PC)      </p><pre><code>mosquitto_pub -h &lt;server-ip&gt; -t test -m \"This is a message from an external device: Hello, MQTT!\" -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> <li> <p>The message should be visible in the MyMQTT Dashboard</p> <p></p> </li> </ol>"},{"location":"mqtt/getting_started/part3_external_connections/#summary-of-key-configuration-file-changes","title":"Summary of Key Configuration File Changes","text":"<pre><code>listener 1883\nallow_anonymous false\npassword_file /etc/mosquitto/passwords.txt\n</code></pre> <p>After completing these steps, Mosquitto will accept external connections (i.e., from external devices, but in the local network) on port 1883, and only users with valid credentials can publish or subscribe.</p> <p>CONGRATULATIONS!</p> <p>You have created your first MQTT local network and are able to communicate devices in the network using this protocol and to monitor the traffic of the network</p>"},{"location":"mqtt/lab1/","title":"Lab Session: MQTT with M5Core2","text":"<p>TBD</p>"},{"location":"real-time/","title":"Real-Time","text":""},{"location":"real-time/#real-time-for-embedded-systems","title":"Real-Time for Embedded Systems","text":"<ul> <li> <p>External data acquisition \"Topic 1\".</p> <p>Note 1.</p> </li> <li> <p>Event-driven multi-tasking: \"Topic 2\".</p> <p>Note 2.</p> </li> <li> <p>Lab Session 1: \"RT multi-tasking without OS\".</p> <p>Note 3.</p> </li> <li> <p>Intro to RTOS: \"Topic 3\".</p> <p>Note 2.</p> </li> <li> <p>Lab Session 2: \"Multi-tasking with RTOS\".</p> <p>Note 3.</p> </li> </ul>"},{"location":"real-time/event-driven/","title":"Event-driven multi-tasking","text":"<p>TBD</p>"},{"location":"real-time/external_data/","title":"External data acquisition","text":"<p>TBD</p>"},{"location":"real-time/freeRTOS/","title":"Introduction to RTOS","text":"<p>TBD</p>"},{"location":"real-time/lab1/","title":"Lab Session: RT multi-tasking without OS","text":"<p>TBD</p>"},{"location":"real-time/lab2/","title":"Lab Session: Multi-tasking with RTOS","text":"<p>TBD</p>"}]}