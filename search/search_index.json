{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Industrial Informatics","text":""},{"location":"#industrial-informatics","title":"Industrial Informatics","text":"<p>Course material for the second part and Lab sesions of the Industrial Informatics course at the University of M\u00e1laga. </p> <p>By Juan M. Gandarias </p> <p>Systems Engineering and Automation Department</p> <p>Find out more...</p>"},{"location":"about/","title":"Welcome","text":""},{"location":"about/#welcome","title":"Welcome","text":"<p>This is the home of the Industrial Informatics course: A fourth-year undergraduate course for Electronics Engineering students in the School of Industrial Engineering at the University of M\u00e1laga.  The content of this website is being developed by Prof. Juan M. Gandarias, an Assistant Professor in the Systems Engineering and Automation Department. The course of Industrial Informatics and its content at the University is given by Prof. Carlos P\u00e9rez-de-Pulgar and Prof. Juan M. Gandarias.</p>"},{"location":"about/#course-content","title":"Course content","text":"<ul> <li>Intro to the course</li> <li>Microcontrollers programming</li> <li>Real-Time Systems Control</li> <li>Real-Time in Embedded Systems</li> <li>Human-Machine Interfaces</li> <li>Internet of Things with MQTT</li> </ul>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>The delivery of these materials following this format has been inspired by the work done by Dr. Tom Howard in the COM2009-3009 Robotics Course at The University of Sheffield. In addition, the content presented has been inspired by various sources listed below.</p>"},{"location":"about/acknowledgements/#general","title":"General","text":"<ul> <li>Luis LLamas Tutorials.</li> <li>Arduino.</li> <li>ESP-IDF.</li> <li>M5Stack.</li> <li>Wokwi.</li> <li>FreeRTOS.</li> </ul>"},{"location":"about/acknowledgements/#real-time-control-systems","title":"Real-Time Control Systems","text":"<ul> <li>W. Bolton, \u201cMecatr\u00f3nica, Sistemas de control electr\u00f3nico en la ingenier\u00eda mec\u00e1nica y el\u00e9ctrica\u201d, Ed. Marcombo, 2010.\u200b</li> <li>S. Bennett, \u201cReal-Time Computer Control, An Introduction\u201d, Ed. Prentice Hall, 1994.\u200b</li> <li>A. Alonso y A. Crespo Lorente, \u201cUna panor\u00e1mica de los Sistemas de Tiempo Real,\u201d Revista Iberoamericana de Autom\u00e1tica e Inform\u00e1tica Industrial, vol. 3, n.o 2, p\u00e1gs. 7-18, 2010.</li> </ul>"},{"location":"about/acknowledgements/#real-time-embedded-systems","title":"Real-Time Embedded Systems","text":"<ul> <li>J. R. Z. Flores, \u201cPlanificaci\u00f3n est\u00e1tica de procesos en sistemas de tiempo real cr\u00edtico,\u201d Tesis doct., Universidad Polit\u00e9cnica de Madrid, 1995.\u200b</li> <li>A. Burns y A. J. Wellings, Real-time systems and programming languages: Ada 95, real-time Java, and real-time POSIX. 2001.\u200b</li> <li>J. W. Liu, Real-time systems. 2006.\u200b</li> </ul>"},{"location":"about/acknowledgements/#hmi","title":"HMI","text":"<ul> <li>J. Raskin, The humane interface: new directions for designing interactive systems. Addison-Wesley Professional, 2000. \u200b</li> <li>J. W. Satzinger y L. Olfman, \u201cUser interface consistency across end-user applications: the effects on mental models,\u201d Journal of Management Information Systems, vol. 14, n.o 4, p\u00e1gs. 167-193, 1998.</li> </ul>"},{"location":"about/acknowledgements/#mqtt","title":"MQTT","text":"<ul> <li>R. Buyya y A. V. Dastjerdi, Internet of Things: Principles and paradigms. Elsevier, 2016.</li> <li>K. Ashton et al., \u201cThat \u2018internet of things\u2019 thing,\u201d RFID journal, vol. 22, n.o 7, p\u00e1gs. 97-114, 2009.</li> <li>Fremantle et al., \u201cA reference architecture for the internet of things,\u201d WSO2 White paper, p\u00e1gs. 02-04, 2015.</li> <li>Y. Zhang y F. Tao, Optimization of manufacturing systems using the Internet of Things. Academic Press, 2016.</li> <li>M. Schwartz, Internet of Things with ESP8266. Packt Publishing Ltd, 2016.</li> <li>T. Pulver, Hands-On Internet of Things with MQTT: Build connected IoT devices with Arduino and MQ Telemetry Transport (MQTT). Packt Publishing Ltd, 2019.</li> <li>L. R. Kanagachidambaresan, Internet of Things Using Single Board Computers: Principles of IoT and Python Programming. Springer, 2022.</li> </ul>"},{"location":"about/changelog/","title":"Version History","text":""},{"location":"about/changelog/#iteration-2","title":"Iteration 2","text":"<p>Academic Year: 2025-2026</p> <ul> <li>All lab sessions included.</li> <li>First version of getting started.</li> <li>WIP documentation.</li> </ul>"},{"location":"about/changelog/#iteration-1","title":"Iteration 1","text":"<p>Academic Year: 2024-2025</p> <ul> <li>Initial release of the material.</li> <li>Included MQTT material only (for now...).</li> </ul>"},{"location":"about/license/","title":"License","text":"<p> This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. </p> <p>You are free to distribute, remix, adapt, and build upon this work (for non-commercial purposes only) as long as credit is given to the original author.</p> <p>For more information, check this link.</p>"},{"location":"hmi/","title":"KMI","text":""},{"location":"hmi/#human-machine-interfaces","title":"Human-Machine Interfaces","text":"<ul> <li> <p>Lab Session 7: TFT LCD Screen.</p> <p>In this exercise you will learn how to simulate microcontrollers with Wokwi.</p> </li> </ul>"},{"location":"hmi/lab7/","title":"Lab Session 7: TFT LCD Screen","text":""},{"location":"hmi/lab7/#lab-session-7-tft-lcd-screen","title":"Lab Session 7: TFT LCD Screen","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"hmi/lab7/#1-title","title":"1. Title","text":""},{"location":"intro/","title":"Introduction","text":""},{"location":"intro/#introduction-to-the-course","title":"Introduction to the course","text":"<ul> <li> <p>Getting started: An introduction to the course.</p> <p>This page summarizes the prerequisites of the course</p> </li> <li> <p>Wokwi local: Use wokwi in VSCode.</p> <p>Here you can learn how to use wokwi in your PC (VSCode) instead of the browser</p> </li> </ul>"},{"location":"intro/getting_started/","title":"Getting Started","text":""},{"location":"intro/getting_started/#getting-started","title":"Getting Started","text":""},{"location":"intro/getting_started/#1-what-is-a-microcontroller","title":"1. What is a Microcontroller?","text":"<p>A microcontroller is a compact integrated circuit designed to perform specific tasks within an embedded system. Unlike general-purpose computers, microcontrollers are optimized for controlling devices, sensors, and actuators in real-time applications. Key characteristics:</p> <ul> <li>Low power consumption</li> <li>Real-time processing capabilities</li> <li>Integration of CPU, memory, and peripherals on a single chip</li> </ul> <p>Microcontrollers are widely used in automation, robotics, IoT devices, and industrial control systems.</p>"},{"location":"intro/getting_started/#2-course-hardware-and-tools","title":"2. Course Hardware and Tools","text":"<p>In this course, we will use the following components and tools:</p>"},{"location":"intro/getting_started/#21-esp32-microcontroller","title":"2.1. ESP32 Microcontroller","text":"<p>The ESP32 is a powerful and versatile microcontroller featuring:</p> <ul> <li>Dual-core processor</li> <li>Built-in Wi-Fi and Bluetooth</li> <li>Multiple GPIO pins for sensors and actuators</li> <li>Support for various communication protocols (I2C, SPI, UART)</li> </ul>"},{"location":"intro/getting_started/#22-wokwi-simulator","title":"2.2. Wokwi Simulator","text":"<p>Wokwi is an online simulator that allows you to:</p> <ul> <li>Prototype circuits without physical hardware</li> <li>Test and debug Arduino, ESP32, and other microcontrollers projects</li> <li>Visualize sensor and actuator behavior in simulated real-time</li> </ul>"},{"location":"intro/getting_started/#23-arduino-ide","title":"2.3. Arduino IDE","text":"<p>The Arduino Integrated Development Environment (IDE) will be our main programming tool. It provides:</p> <ul> <li>A simple interface for writing and uploading code</li> <li>Extensive libraries for sensors, displays, and communication</li> <li>Cross-platform compatibility (Windows, macOS, Linux)</li> </ul>"},{"location":"intro/getting_started/#24-m5core2-development-kit","title":"2.4. M5Core2 Development Kit","text":"<p>The M5Core2 is an ESP32-based device with:</p> <ul> <li>A touchscreen display</li> <li>Built-in sensors and expansion ports</li> <li>A modular design for rapid prototyping</li> </ul>"},{"location":"intro/getting_started/#3-additional-programming-material","title":"3. Additional Programming Material","text":"<p>If you don't feel confident enough to follow the content of this course due to lack of programming knowledge, or maybe you've taken a course on coding before but it's been a while since since then and don't remember well how to do it, here you have some extra material that could help you.</p> <p>In this course we'll code ESP32-based microcontrollers in C/C++ usign the Arduino IDE.</p> <p>There are several sources of information in the internet you could use for free. Here are the ones I find the most useful for the purpose of this course:</p>"},{"location":"intro/getting_started/#31-learn-c","title":"3.1. Learn C++","text":"<p>In this website you have all the necessary information on how to program in C++. Including many elements that go beyond the content of this course.</p>"},{"location":"intro/getting_started/#32-luis-llamas-introduction-to-programming-course","title":"3.2. Luis Llamas' Introduction to Programming Course","text":"<p>This is a course that covers general topics of programming (you can find it in Engish and Spanish). In many of the entries you can find examples in different languages (don't forget to select C/C++). The list below shows:</p> <ol> <li>The Minimum concepts you should know before taking this course. Without this knowledge, it'd be hard for you to follow this course.</li> <li>The Desired concepts to have before taking this course. It completes the previous list and if you have them, you'll be able to follow the course without any problem.</li> <li>The Advanced concepts. It completes the two preivious lists. If you have the, your code knowdlege exceedes the required for this course.</li> </ol>"},{"location":"intro/getting_started/#321-minimum-concepts","title":"3.2.1. Minimum concepts","text":"<ol> <li> <p>Introduction</p> <ul> <li>What is programming</li> <li>Brief history of programming</li> <li>Evolution of languages</li> <li>Software development phases</li> </ul> </li> <li> <p>Fundamentals</p> <ul> <li>Types of programs</li> </ul> </li> <li> <p>Frequent Concepts</p> <ul> <li>What is a library</li> <li>What are dependencies</li> <li>Semantic versioning</li> <li>Packages and package managers</li> </ul> </li> <li> <p>Tools</p> <ul> <li>What is an IDE</li> </ul> </li> <li> <p>Program Structure</p> <ul> <li>Program structure</li> <li>Program lifecycle</li> <li>Statements and blocks</li> <li>What is indentation</li> <li>What are comments</li> </ul> </li> <li> <p>Expressions and Operators</p> <ul> <li>Operators and expressions</li> <li>Operator precedence</li> <li>Access operators</li> <li>Assigment operators</li> <li>Arithmetic operators</li> <li>Comparison operators</li> <li>Logical operators</li> </ul> </li> <li> <p>Variables</p> <ul> <li>What is a variable</li> <li>What is a constant</li> </ul> </li> <li> <p>Data Types</p> <ul> <li>Data types</li> <li>Typed and untyped languages</li> </ul> </li> <li> <p>Common types</p> <ul> <li>Boolean</li> <li>Numeric</li> <li>Text</li> </ul> </li> <li> <p>Control Flow</p> <ul> <li>what is control flow</li> <li>Go-to statemet</li> <li>What is a conditional</li> <li>What is a loop</li> </ul> </li> <li> <p>Conditionals</p> <ul> <li>If</li> <li>If-else</li> <li>If-elseif</li> <li>Switch</li> </ul> </li> <li> <p>Loops</p> <ul> <li>While</li> <li>Do-while</li> <li>For</li> </ul> </li> <li> <p>Functions</p> <ul> <li>What is a function</li> </ul> </li> </ol>"},{"location":"intro/getting_started/#322-desired-concepts","title":"3.2.2. Desired concepts","text":"<ol> <li> <p>Fundamentals</p> <ul> <li>Machine code</li> </ul> </li> <li> <p>Tools</p> <ul> <li>Top IDEs</li> <li>Source code control</li> </ul> </li> <li> <p>Variables</p> <ul> <li>Variable scope</li> </ul> </li> <li> <p>References</p> <ul> <li>What is a reference</li> <li>Type value and reference</li> <li>Parameters by value or reference</li> </ul> </li> <li> <p>Conditionals</p> <ul> <li>Nested conditionals</li> </ul> </li> <li> <p>Loops</p> <ul> <li>Nested loops</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Function Parameters</li> <li>Function return value</li> <li>Function overloading</li> </ul> </li> <li> <p>Collections</p> <ul> <li>Arrays</li> </ul> </li> <li> <p>Data Structures</p> <ul> <li>Structs</li> </ul> </li> </ol>"},{"location":"intro/getting_started/#323-advanced-concepts","title":"3.2.3. Advanced concepts","text":"<ol> <li> <p>Fundamentals</p> <ul> <li>Assembly language</li> </ul> </li> <li> <p>Tools</p> <ul> <li>Visual Studio Code</li> <li>Node.js</li> <li>NPM</li> </ul> </li> <li> <p>Variables</p> <ul> <li>Destructuring</li> </ul> </li> <li> <p>Data Types</p> <ul> <li>Type deduction</li> </ul> </li> <li> <p>Common types</p> <ul> <li>Time</li> <li>Enums</li> <li>Collection</li> <li>Grouping</li> </ul> </li> <li> <p>References</p> <ul> <li>Function references</li> </ul> </li> <li> <p>Control Flow</p> <ul> <li>Exceptions and Try-Catch</li> </ul> </li> <li> <p>Conditionals</p> <ul> <li>Ternary operator</li> </ul> </li> <li> <p>Loops</p> <ul> <li>Foreach</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Lambda functions</li> <li>Recursive functions</li> <li>Passing functions as parameters</li> </ul> </li> <li> <p>Collections</p> <ul> <li>Dynamic arrays</li> <li>HashSet</li> <li>Dictionaries</li> <li>LinkedLists</li> <li>Stacks</li> <li>Queue</li> <li>Efficiency of collections</li> </ul> </li> <li> <p>Data Structures</p> <ul> <li>Objects</li> <li>Object oriented programming</li> <li>Tuples</li> <li>Graphs</li> <li>Trees</li> </ul> </li> <li> <p>Asynchrony</p> <ul> <li>Asynchronous programming (we'll see it in Lecture 6)</li> <li>Concurrency and Paralellism (we'll see it in Lecture 6)</li> </ul> </li> </ol>"},{"location":"intro/getting_started/#4-additional-esp32-material","title":"4. Additional ESP32 Material","text":"<p>More material about how to program microcontrollers (ESP32, in particular) can be found in Luis Llamas' website, here and here. Some of this material will be covered in our course.</p>"},{"location":"intro/wokwi_local/","title":"Use Wokwi in VSCode (local)","text":""},{"location":"intro/wokwi_local/#use-wokwi-in-vscode-local","title":"Use Wokwi in VSCode (local)","text":"<p>This page explains how to use Wokwi inside Visual Studio Code. </p>"},{"location":"intro/wokwi_local/#why-do-you-want-to-use-wokwi-inside-vs-code","title":"Why do you want to use Wokwi inside VS Code?","text":"<p>When using Wokwi in the browser you may have noticed some delays when compiling the project.</p> <p></p> <p>This is because everytime a user press the Start simulation button, the code has to be, first compiled (the user sends a compilation request when pressing the button), and then simulated. Compiling code takes some time (especially for large codes or when using several libraries). Hence, the compilation request gets queued and waits to be attended by the Wokwi server to get the compilation done. If the server is very busy (i.e., many requests with high amounts of code occurring at the same time), your compilation request may be queued for long time even though your code takes very short time to be compiled, and you experience high delays.</p> <p>If you use Wokwi in VS Code, you'll still use Wokwi server to simulate your code (i.e., you need internet connection as the simulation won't run in your local machine), but you'll compile your code in your local machine and tell Wokwi where are the binaries to be used for the simulation. This way you'll skip the main reason of the delays: the compilation request queue.</p>"},{"location":"intro/wokwi_local/#installation","title":"Installation","text":"<p>You have to do the following:</p> <ol> <li>Install VS Code:<ul> <li>You can download it from here.</li> </ul> </li> <li> <p>Install the Wokwi for VS Code extension:</p> <ul> <li>You can install it directly from the Extensions panel inside VS Code (recommended).</li> </ul> <p></p> <ul> <li>You can also install it from here.</li> </ul> </li> <li> <p>Install the Arduino Community Edition for VS Code extension:</p> <p></p> </li> </ol>"},{"location":"intro/wokwi_local/#wokwi-license","title":"Wokwi license","text":"<p>Wokwi is free, but to use it locally in your machine you need a licence. If you don't want (or can't) pay for it, you can use the 30-days free license. Don't worry, after these 30 days you can renovate the free license again. </p> <p>To get your license you need to do the following:</p> <ol> <li>First, you need to create a Wokwi account. You can do this from the browser.</li> <li> <p>Open VS Code, press F1 (to open the command palette)  and write <code>Wokwi: Request a New License</code>.</p> <p></p> </li> <li> <p>When you get the following message click on <code>Open</code>.</p> <p></p> </li> <li> <p>When the new tab is open in your browser, click on <code>Get your license</code>.</p> <p></p> </li> <li> <p>VS Code will show you the following message. Select <code>Do not ask me again</code> and click on <code>Open</code>. Now, your wokwi license is activated in VS Code and will expire after 30 days.</p> <p></p> </li> </ol> <p>Failure</p> <p>If VS Code does not automatically detect your license key in step 4, you can copy the key (the super long alphanumeric chain ) and press F1 in VS Code, then type <code>Wokwi: Manually Enter License Key</code>, and paste the key there</p> <p>Info</p> <p>When your license expires, you can repeat this process and get another 30-days free license.</p>"},{"location":"intro/wokwi_local/#create-your-wokwi-project-in-vs-code","title":"Create your Wokwi project in VS Code","text":"<p>As you may already know, when using Wokwi in the browser you need, at least, two files. These files are <code>sketch.ino</code> and the <code>diagram.json</code>. To use Wokwi in VS Code you'll need some more files. </p> <ol> <li> <p>First, create your project in your local computer. You can do this by hand or you can download a template here. If you download that template, you need to unzip it.</p> </li> <li> <p>Open your project from VS Code</p> <p></p> </li> <li> <p>Once the project is open, you should see the following:</p> <p></p> <ul> <li>build: This is an empty folder at this moment. Here is where the binaries will be storage when you compile your code.</li> <li> <p>diagram.json: This is the same <code>diagram.json</code> as the one in the browser version. I.e., the definition of the system components and connections.</p> <p>Tip</p> <p>The best way to edit this file is to use thw GUI in the browser. I.e., create your diagram in the browser  app, copy the code inside the <code>diagram.json</code> and then go to your local project in VS Code and paste it there. This is because you don't have the GUI in VS Code (you can only edit the text).</p> <p>Warning</p> <p>It might happen that if you double-click this file aiming at editing it, you'll see the diagram instead of the code. If you press with the right-click on top of the file name and click on Open with and then Text editor you'll be able to see the code.</p> <p></p> <p></p> </li> <li> <p>template_wokwi.ino: This is the same as the <code>sketch.ino</code> in the browser. I.e., your arduino code.</p> </li> <li> <p>wokwi.toml: This file contains the path of the binary files that wokwi needs to start the simulation. I.e., where the binaries after the compilation will go. If you open this file you will see the following:</p> <pre><code>[wokwi]\nversion = 1\nfirmware='build/template_wokwi.ino.bin'\nelf='build/template_wokwi.ino.elf'\n</code></pre> </li> </ul> <p>Danger</p> <ul> <li>As you may notice, this project is called <code>template_wokwi</code>. It is critical that the name of the project is the same as the name of the <code>.ino</code> file, and the one inside the <code>toml</code> file. </li> <li>Hence, if your project is called <code>project_test</code>, then you should have the following:</li> </ul> <pre><code>project_test\n    |\n    |\u2500\u2500 build\n    |\u2500\u2500 diagram.json\n    |\u2500\u2500 project_test.ino\n    \u2514\u2500\u2500 wokwi.toml\n</code></pre> <ul> <li>And inside the <code>.toml</code> you should have:</li> </ul> <pre><code>[wokwi]\nversion = 1\nfirmware='build/project_test.ino.bin'\nelf='build/project_test.ino.elf'\n</code></pre> </li> </ol>"},{"location":"intro/wokwi_local/#compile-your-project","title":"Compile your project","text":"<p>To start the simulation, the project must be previously compiled. To do this you first must install the boards we're using in wokwi (ESP32), tell VS Code the board you want to compile the code for, and compile the code inside the build folder</p> <ol> <li> <p>Install the ESP32 boards. </p> <ul> <li> <p>Press F1 and type <code>Arduino: Board Manager</code>.</p> <p></p> </li> <li> <p>Install the ESP32 board of Espressif.</p> <p></p> <p>Warnig</p> <p>Remember to install the correct version! In the picture above the version selected is 3.2.0, meaning that it'll compile using the version 3 of the Espressif API. If you're using code of version 2, you must select a 2.X version (e.g., 2.0.17). Check this website for more info.</p> </li> </ul> </li> <li> <p>Change the target board to compile the code.</p> <ul> <li> <p>Press F1 and type <code>Arduino: Change Board Type</code>.</p> <p></p> </li> <li> <p>Select the <code>ESP32 Dev Module</code> board.</p> <p></p> </li> </ul> </li> <li> <p>After doing this you'll notice that a new file inside a hidden folder (hidden files and folers starts with <code>.</code>, here the folder <code>.vscode</code> is a hidden folder) has been created in your project <code>.vscode/arduino.json</code>. This is a configuration file that tells VS Code which board are you compiling for and where the binaries will be saved after the compilation.</p> <ul> <li>Originally this file looks like this: <pre><code>{\n    \"configuration\": \"JTAGAdapter=default,PSRAM=disabled,PartitionScheme=default,CPUFreq=240,FlashMode=qio,FlashFreq=80,FlashSize=4M,UploadSpeed=921600,LoopCore=1,EventsCore=1,DebugLevel=none,EraseFlash=none\",\n    \"board\": \"esp32:esp32:esp32\"\n}\n</code></pre></li> <li>You must change it and write the following: <pre><code>{\n    \"board\": \"esp32:esp32:esp32\",\n    \"sketch\": \"template_wokwi.ino\",\n    \"output\": \"build\"\n}\n</code></pre></li> </ul> <p>Warning</p> <p>Notice that here you're telling VS Code that you're going to compile for the <code>esp32</code> board, that the sketch you want to compile is <code>template_wokwi.ino</code> (note that if you have changed the name of the project, you must change it here too), and that the output binaries will be saved in the folder <code>build</code>.</p> </li> <li> <p>Once you have done this, you can compile your project.</p> <ul> <li>Press F1 and type <code>Arduino: Verify</code>. This will compile the code. Hence, if there's any compilation error, you'll be abole to see it in the VS Code terminal.</li> </ul> <p></p> <ul> <li>Once the compilation is done, you should be able to see a bunch of new files inside the previously-empty <code>build</code> folder. Notice that you have the files <code>template_wokwi.ino.bin</code> and <code>template_wokwi.ino.elf</code></li> </ul> <p></p> </li> </ol>"},{"location":"intro/wokwi_local/#simulate-your-project","title":"Simulate your project","text":"<p>Once your project is correctly compiled, you can double-click on <code>diagram.json</code> and start the simulation.</p> <p></p> <p>Warning</p> <p>If you simulate a project, and then make changes in the code, you must compile it again. It may happen to you that after doing this, when you press start the simulation again, you don't see the last changes you have made.</p> <p>This is because everytime you want to change somenthing in your code you must close the simulation window, compile the code with <code>Arduino: Verify</code>, and re-open the simulation window. If you don't close and open the simulation window you very probably won't see the effects.</p>"},{"location":"intro/wokwi_local/#full-example","title":"Full example","text":"<p>You can download a full example here.</p> <p>The result of the simulation are shown in this video (note that when you open the <code>diagram.json</code> it will compile the code - it is shown in the video):</p> <p></p>"},{"location":"intro/wokwi_local/#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Project name     One of the most common errors happen when you want to change the name of the project after compiling a couple of times.     As you may have noticed during this guide, Wokwi for VS Code is extremely sensitive to the project name. This means you must be extremely careful when changing it. </p> <p>If you want to change the project name after compiling it, my suggestion is to do the following:</p> <ol> <li>Delete every file inside the build folder (previous compiled code).</li> <li>Delete the <code>.vscode/c_cpp_properties.json</code> file.</li> <li>Change the name of the project folder.</li> <li>Change the name of the <code>.ino</code> file.</li> <li>Change the name of the sketch inside the <code>.vscode/arduino.json</code> file.</li> <li>Change the name of the <code>firmware</code> and <code>elf</code> inside the <code>wokwi.toml</code> file.</li> </ol> </li> </ol> <p>You can find an updated guide here.</p>"},{"location":"microcontrollers_programming/","title":"Introduction","text":""},{"location":"microcontrollers_programming/#microcontrollers-programming","title":"Microcontrollers programming","text":"<ul> <li> <p>Lab Session 1: Intro to microcontrollers programming.</p> <p>Here, you will explore the fundamentals of programming microcontrollers. In this exercise you will learn how to simulate microcontrollers with Wokwi and how to setup the Arduino IDE for the course.*</p> </li> <li> <p>Lab Session 2: Timers.</p> <p>Here, you will explore how to use timers in microcontrollers.</p> </li> <li> <p>Lab Session 3: PWM.</p> <p>Here, you will explore how to use Pulse Width Modulation (PWM) signals.</p> </li> <li> <p>Lab Session 4: Incremental Encoders.</p> <p>Here, you will explore how to use external interruptions to read incremental encoders.</p> </li> <li> <p>Arduino ESP32 core:: 2.x and 3.x versions.</p> <p>Here, you will explore how to use external interruptions to read incremental encoders.</p> </li> </ul>"},{"location":"microcontrollers_programming/arduino_esp32_core/","title":"Arduino ESP32 core 2.x and 3.x","text":""},{"location":"microcontrollers_programming/arduino_esp32_core/#arduino-esp32-core-2x-and-3x","title":"Arduino ESP32 core 2.x and 3.x","text":"<p>In 2024, the Arduino\u2011ESP32 core was upgraded from versions 2.x (based on ESP-IDF 4.4) to versions 3.x (based on ESP-IDF 5.1). The underlying API and build system (usually called API or builder) changed some behaviour around several functionalities.</p> <p>As you'll use PWM and timers extensively in this course, which suffered breaking changes from this update, it's necessary to consider which version are you using when developing your programs. Below are the most relevant points, practical guidance and short code examples you can use when porting or writing your code.</p> <p>For more information about this migration you can check this website.</p> <p>First of all, you need to know that even if the code sinatxis and structure has suffered some changes, the results in reality that can be achieved using one or another (at least, for what you'll do in this course) are not affected by this migration (considering that the code is well developed independently of the API version).</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#timers","title":"Timers","text":"<p>In this course you'll need to program hardware timers. Although the functionalities when using the API versions 2.x or 3.x are basically the same, the code sintaxis and structure changes a bit.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#using-arduino-esp32-core-2x","title":"Using Arduino ESP32 core 2.x","text":""},{"location":"microcontrollers_programming/arduino_esp32_core/#list-of-instructions","title":"List of instructions","text":"<pre><code>hw_timer_t *timer_name = NULL;\n</code></pre> <ul> <li>Declares a pointer named <code>timer_name</code> whose type is <code>hw_timer_t</code> (a handle/opaque struct representing a hardware timer on the ESP32) and initializes it to NULL to avoid an uninitialized/dangling pointer. Typical usage: assign the pointer the value returned by <code>timerBegin(...)</code>, then use it with API calls such as <code>timerAttachInterrupt(...)</code> or <code>timerAlarmWrite(...)</code>. Here you just need to change the timer_name (don't forget the *).</li> </ul> <pre><code>timer_name = timerBegin(uint8_t timer_index, uint16_t prescaler, bool count_up);\n</code></pre> <ul> <li>timer_index: ESP32 has 4 timers. The timer index can be 0,1,2,3.</li> <li>prescaler: The default ESP32 clock runs at 80MHz. If you put <code>prescaler=80</code> you can count every \u00b5s.</li> <li>count_up: If you set <code>count_up=true</code>, the timer will count upwards (you'll usually use this mode).</li> </ul> <pre><code>timerAttachInterrupt(hw_timer_t *timer_name, void &amp;timer_ISR_name, bool edge\u2011triggered);\n</code></pre> <ul> <li>timer_name: The first parameter is the same timer name.</li> <li>timer_ISR_name: is the name of the timer callback (don't forget the &amp;).</li> <li>edge\u2011triggered: If you set <code>edge\u2011triggered=true</code>, the timer callback will be edge-triggered, otherwise, it'll be level-triggered (you'll usually use the first one).</li> </ul> <pre><code>timerAlarmWrite(hw_timer_t timer_name, uint64_t num_ticks, bool autoreload);\n</code></pre> <ul> <li>timer_name: The first parameter is the same timer name.</li> <li>num_ticks: number of timer ticks before the alarm fires (NOT necessarily microseconds; it is in ticks determined by your prescaler).</li> <li>autoreload: bool: true = automatic reload (periodic), false = one\u2011shot (you'll usually set it to true)</li> </ul> <p>More about the Timers in version 2 here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#minimal-example","title":"Minimal example","text":"<pre><code>hw_timer_t *timer = NULL; // Pointer to the hardware timer.\n// I called it \"timer\" for simplicity, but it could be named anything. e.g.:\n// hw_timer_t *temporizador_0 = NULL;\n\n// ...some code...\n\n// ISR callback for timer interrupt\nvoid IRAM_ATTR timerInterrupt()\n{\n    // ...some code...\n}\n\n// setup function\nvoid setup()\n{\n    // ...some code...\n\n    // Initialize the timer\n    // Parameter 1: Timer index to use. ESP32 has 4 timers =&gt; valid values 0,1,2,3\n    // Parameter 2: Prescaler. The default ESP32 clock runs at 80MHz. If we set 80, we divide the clock by 80, giving 1,000,000 ticks/s (i.e., 1 tick per \u00b5s)\n    // Parameter 3: true indicates the timer counts up, false would count down\n    timer = timerBegin(0, 80, true);                    // Timer 0, clock divider 80\n    timerAttachInterrupt(timer, &amp;timerInterrupt, true); // Attach the interrupt handler\n    timerAlarmWrite(timer, 5e5, true);                  // Interrupt every 500ms (500000 \u00b5s), auto-reload\n\n    // ...some code...\n}\n\n// ...some code...\n</code></pre>"},{"location":"microcontrollers_programming/arduino_esp32_core/#full-example","title":"Full example","text":"<p>When you pressed the button, the LED will blink five times every 1s (i.e., 500ms ON, 500ms OFF). You can find a full example here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#using-arduino-esp32-core-3x","title":"Using Arduino ESP32 core 3.x","text":""},{"location":"microcontrollers_programming/arduino_esp32_core/#list-of-instructions_1","title":"List of instructions","text":"<pre><code>hw_timer_t *timer_name = NULL;\n</code></pre> <ul> <li>Declares a pointer named <code>timer_name</code> whose type is <code>hw_timer_t</code> (a handle/opaque struct representing a hardware timer on the ESP32) and initializes it to NULL to avoid an uninitialized/dangling pointer. Typical usage: assign the pointer the value returned by <code>timerBegin(...)</code>, then use it with API calls such as <code>timerAttachInterrupt(...)</code> or <code>timerAlarmWrite(...)</code>. Here you just need to change the timer_name (don't forget the *).</li> </ul> <pre><code>timer_name = timerBegin(uint32_t timer_frequency);\n</code></pre> <ul> <li>timer_frequency: desired timer tick frequency in Hz (how fast the timer counts).</li> </ul> <pre><code>timerAttachInterrupt(hw_timer_t timer_name, void &amp;timerInterrupt);\n</code></pre> <ul> <li>timer_name: The first parameter is the same timer name.</li> <li>timer_ISR_name: is the name of the timer callback (don't forget the &amp;).</li> </ul> <pre><code>timerAlarm(hw_timer_t timer_name, uint64_t num_ticks, bool autoreload, uint32_t repeat_count);\n</code></pre> <ul> <li>timer_name: The first parameter is the same timer name.</li> <li>num_ticks: number of timer ticks before the alarm fires (NOT necessarily microseconds; it is in ticks determined by your prescaler).</li> <li>autoreload: bool: true = automatic reload (periodic), false = one\u2011shot (you'll usually set it to true).</li> <li>repeat_count: 0 = run indefinitely, &gt;0 = number of repeats.</li> </ul> <pre><code>timerStart(timer_name);  \n</code></pre> <ul> <li>Starts the timer.</li> </ul> <pre><code>timerStop(timer_name);  \n</code></pre> <ul> <li>Stops the timer.</li> </ul> <p>More about the Timers in version 3 here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#minimal-example_1","title":"Minimal example","text":"<pre><code>hw_timer_t *temporizador = NULL; // Pointer to the hardware timer.\n// I named it \"temporizador\" for simplicity, but it can be any valid identifier. e.g.: hw_timer_t *my_timer_0 = NULL;\nint timer_frequency = 1000000; // Timer frequency in Hz (how fast the timer counts)\n\n// ...some code...\n\n// ISR callback for timer interrupt\nvoid IRAM_ATTR timerInterrupt()\n{\n    // ...some code...\n}\n\nvoid setup()\n{\n    // ...some code...\n\n    temporizador = timerBegin(timer_frequency);          // Initialize the timer that will count at timer_frequency\n    timerAttachInterrupt(temporizador, &amp;timerInterrupt); // Attach the interrupt handler\n    // Set the timer alarm (param 1) so it calls timerInterrupt every half second (param 2 - value in microseconds)\n    // Set true to repeat the alarm (param 3) and 0 to run indefinitely (param 4 - 0 = indefinite)\n    timerAlarm(temporizador, 500000, true, 0);\n\n    // ...some code...\n}\n\n// ...some code...\n</code></pre>"},{"location":"microcontrollers_programming/arduino_esp32_core/#full-example_1","title":"Full example","text":"<p>When you pressed the button, the LED will blink five times every 500ms (i.e., 250ms ON, 250ms OFF). You can find a full example here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#pwm-ledc","title":"PWM (LEDC)","text":"<p>In this course you'll need to use PWM signals. Although the functionalities when using the API versions 2.x or 3.x are basically the same, the code sintaxis and structure changes a bit.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#using-arduino-esp32-core-2x_1","title":"Using Arduino ESP32 core 2.x","text":""},{"location":"microcontrollers_programming/arduino_esp32_core/#list-of-instructions_2","title":"List of instructions","text":"<pre><code>void ledcSetup(uint8_t channel, uint32_t frequency, uint8_t resolution);\n</code></pre> <ul> <li>channel: LEDC channel number (use a free channel, typically 0..15).</li> <li>frequency: PWM frequency in Hz.</li> <li>resolution: PWM resolution in bits; duty values range 0 .. (\\(2^{resolution} - 1\\)).</li> </ul> <pre><code>void ledcAttachPin(uint8_t pin, uint8_t channel);\n</code></pre> <p>Connects (maps) the specified GPIO <code>pin</code> to the given LEDC PWM <code>channel</code> so the channel's PWM output is driven on that pin.</p> <pre><code>void ledcWrite(uint8_t channel, uint32_t duty);\n</code></pre> <p>Sets the PWM <code>duty</code> cycle (from 0 to \\(2^{resolution} - 1\\))  for a configured LEDC output \u2014 updates the output on the <code>channel</code> so the pin associated to that channel changes its PWM duty cycle.</p> <p>More about the PWM in version 2 here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#minimal-example_2","title":"Minimal example","text":"<pre><code>#define LED_PIN 26\n\nconst int led_channel = 0;\nconst int frequency = 8000;\nconst int resolution = 12;\n\nint duty = 0;\n\n// ...some code...\n\nvoid setup() {\n    // Configure the LEDC PWM channel with specified frequency and resolution\n    ledcSetup(led_channel, frequency, resolution);\n\n    // Attach the configured PWM channel to the LED pin\n    ledcAttachPin(LED_PIN, led_channel);\n\n    // Example: write an initial duty value to the channel\n    // ledcWrite(channel, duty) accepts values in range 0..(2^resolution - 1)\n    ledcWrite(led_channel, duty);\n}\n\n// ...some code...\n</code></pre>"},{"location":"microcontrollers_programming/arduino_esp32_core/#full-example_2","title":"Full example","text":"<p>You can find a full example here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#using-arduino-esp32-core-3x_1","title":"Using Arduino ESP32 core 3.x","text":""},{"location":"microcontrollers_programming/arduino_esp32_core/#list-of-instructions_3","title":"List of instructions","text":"<pre><code>void ledcAttach(uint8_t pin, uint32_t frequency, uint8_t resolution);\n</code></pre> <ul> <li>pin: GPIO pin number to use for PWM (can be treated as int in sketches).</li> <li>frequency: PWM frequency in Hz.</li> <li>resolution: PWM resolution in bits (duty range 0 .. \\(2^{resolution} - 1\\)).</li> </ul> <pre><code>void ledcWrite(uint8_t pin, uint32_t duty); \n</code></pre> <ul> <li>Sets the PWM <code>duty</code> cycle (from 0 to \\(2^{resolution} - 1\\))  for a configured LEDC output \u2014 updates the output on the the pin and changes its PWM duty cycle.</li> </ul> <p>More about the PWM in version 3 here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#minimal-example_3","title":"Minimal example","text":"<pre><code>#define LED_PIN 26\n\n// PWM configuration for Arduino-ESP32 v3.x example\nconst int ledc_freq = 8000;         // PWM frequency in Hz\nconst int ledc_resolution = 12;     // PWM resolution in bits (0..(2^resolution - 1))\nint duty = 0;\n\n// ...some code...\n\nvoid setup() {\n    // Attach/configure PWM on LED_PIN using the new ledc attach API\n    // Parameters: (pin, frequency, resolution)\n    // After this call the pin is configured for PWM with the specified frequency/resolution.\n    ledcAttach(LED_PIN, ledc_freq, ledc_resolution);\n\n    // Write an initial duty value to the PWM channel tied to LED_PIN.\n    // The valid duty range is 0 .. (2^ledc_resolution - 1). For 12-bit resolution that is 0..4095.\n    ledcWrite(LED_PIN, duty);\n\n    // ...some code...\n}\n// ...some code...\n</code></pre>"},{"location":"microcontrollers_programming/arduino_esp32_core/#full-example_3","title":"Full example","text":"<p>You can find a full example here.</p>"},{"location":"microcontrollers_programming/arduino_esp32_core/#working-in-simulation-with-the-arduino-esp32-core-2x","title":"Working in Simulation with the Arduino ESP32 core 2.x","text":"<p>When you open a new project in wokwi, by default the core 3.x is used. Therefore, if you try to use instructions that correspond to core 2.x, you'll receive a compilation error. </p> <p>If you want to use core 2.x in wokwi you can do it by configuring the <code>diagram.json</code>. You need to include <code>\"builder\": \"esp32-core-2.0.3\"</code>in the <code>\"attrs\": { }</code>.</p> <p>Example of <code>diagram.json</code> with builder 3.x in wokwi:</p> <pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": -19.2,\n      \"left\": -33.56,\n      \"attrs\": { }\n    }\n  ],\n  \"connections\": [ [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ], [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ] ],\n  \"dependencies\": {}\n}\n</code></pre> <p>Example of <code>diagram.json</code> with builder 2.x in wokwi:</p> <pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": -19.2,\n      \"left\": -33.56,\n      \"attrs\": { \"builder\": \"esp32-core-2.0.3\" }\n    }\n  ],\n  \"connections\": [ [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ], [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ] ],\n  \"dependencies\": {}\n}\n</code></pre>"},{"location":"microcontrollers_programming/lab1/","title":"Lab Session 1: Intro to microcontrollers programming","text":""},{"location":"microcontrollers_programming/lab1/#lab-session-1-intro-to-microcontrollers-programming","title":"Lab Session 1: Intro to microcontrollers programming","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"microcontrollers_programming/lab1/#1-working-with-real-hardware","title":"1. Working with real hardware","text":""},{"location":"microcontrollers_programming/lab1/#11-prepare-the-arduino-ide","title":"1.1. Prepare the Arduino IDE","text":"<p>Follow the installation steps described in this guide.</p> <ol> <li>Install Arduino IDE: Download it from this link.</li> <li> <p>Install the M5Stack board family:</p> <p></p> <p>You need to copy/paste this text to download the board package</p> <pre><code>https://static-cdn.m5stack.com/resource/arduino/package_m5stack_index.json \n</code></pre> <p></p> <p>Once the board package address is set, you can install it from the boards manager. </p> <p>Warning</p> <p>Remember to install the version 2.1.4. If you try to install version 3.X you won't be able to do exercises of the lab sessions. We'll talk about the versions 2.X and 3.X later and how to migrate our code from one to another. For now, just use the 2.X version.</p> <p>Danger</p> <p>Once you've done this, if you open the Arduino IDE later, a message will pop up letting you know that there are updates available for some libraries and asking whether you want to install the updates or not. Don't update the libraries</p> <p>Info</p> <p>This process may take a few minutes.</p> <p>Once installed, you can select M5Core2 from the board selection menu.</p> <p></p> </li> <li> <p>Install the Arduino libraries for M5Core2:</p> <p></p> <p>Warning</p> <p>When you press Install, you'll see the list of dependencies. You MUST install all the dependencies too.</p> <p>Info</p> <p>This is a long process that may take several minutes. Be patient...</p> <p>Tip</p> <p>In case the list of dependencies is that large that you cannot see the Install All button, you can press the tab key Tab twice to put the cursor over the button and then press Enter to install all the dependencies.</p> </li> <li> <p>Install the CP2104 driver (USB driver):</p> <p>Download it from this link if you're using Windows, from this link if you're using MacOS, or from this other link if you're using Linux.</p> <p>More info about USB driver installation here.</p> <p>Now, when you connect the M5Core2 devide to the PC with the USB cable, you can select the port in the Arduino IDE.</p> <p></p> <p>Info</p> <ul> <li>In windows, the port is called COMX, where X is a number that can vary from time to time, e.g., COM5.</li> <li>In linux, the port is called \"ttyUSBX\" or \"ttyACMX\", where X is a number that can vary from time to time, e.g., ttyUSB2.</li> </ul> </li> <li> <p>Compile and upload the <code>hello_world.ino</code> example from M5Core2 library:</p> <p></p> <p>You can press the Upload (in red) button to compile and load the program to the device. Note that the button on the left (Verify - in green) compiles the program but doesn't upload it to the device.</p> <p></p> </li> <li> <p>OPTIONAL (do it ONLY if you have finished all the exercises of the lab session): You can open other examples if you want to see the potential of M5Core2. You can try this one:</p> <p></p> </li> </ol> <p>Additional resources</p> <p>Here you can find more documentation about some of the basic functions of M5Core2.  </p> <p>Pinout and Important Notes Below is the M5Core2 pinout. The pins marked in red are the ones we will use in the exercises.</p> <p></p> <p>Warning</p> <ul> <li>Some pins on the M5Core2 are preconfigured, so pay attention when connecting external components.</li> <li>The ESP32 inside the M5Core2 has 3 serial ports:<ul> <li><code>Serial1</code> is reserved for the display (do not use it).</li> <li><code>Serial0</code> can be configured (pins <code>G3 \u2013 RXD0</code> and <code>G1 \u2013 TXD0</code>), but it is reserved for USB connection to the PC.</li> <li><code>Serial2</code> is free and can be configured (pins <code>G13 \u2013 RXD2</code> and <code>G14 \u2013 TXD2</code>) as regular GPIO using <code>pinMode()</code>.</li> </ul> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#12-turn-an-led-on-and-off","title":"1.2. Turn an LED ON and OFF","text":"<p>Connect an LED as follows:</p> <p></p> <p>Run the following program: </p><pre><code>#include &lt;M5Core2.h&gt;\n#define LED_PIN 14\n\nvoid setup() {\n  M5.begin(); // Initialize M5Core2\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(LED_PIN, HIGH);\n  delay(500);\n  digitalWrite(LED_PIN, LOW);\n  delay(500);\n}\n</code></pre> <p>Question</p> <ul> <li>What does the <code>#define</code> do?</li> <li>What does the <code>pinMode()</code> function do?</li> <li>What does the <code>digitalWrite()</code> function do?</li> </ul> <p>Question</p> <p>Note that you had to include the <code>#include &lt;M5Core2.h&gt;</code> and the <code>M5.begin(); // Initialize M5Core</code> Why did you have to do that? what are these instructions for?</p>"},{"location":"microcontrollers_programming/lab1/#13-additional-exercises","title":"1.3. Additional exercises","text":""},{"location":"microcontrollers_programming/lab1/#131-blink-at-a-certain-frequency","title":"1.3.1. Blink at a certain frequency","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED at a frequency of 10Hz.</p> <p>Question</p> <ul> <li>For how long does the LED has to be ON or OFF in each cycle?</li> </ul> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#132-blink-and-stop","title":"1.3.2. Blink and stop","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED at a frequency of 2Hz and stops the blinking after 5 seconds.</p> <p>Question</p> <ul> <li>How many times does the LED blink?</li> <li>What is the final state of the LED when the blink stops, does it remain ON or OFF?</li> </ul> <p>Tip</p> <p>You may need to use the <code>for</code> loop, or the  <code>if...else</code> condition.</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#2-working-in-simulation","title":"2. Working in Simulation","text":""},{"location":"microcontrollers_programming/lab1/#21-microcontrollers-simulation","title":"2.1. Microcontrollers simulation","text":""},{"location":"microcontrollers_programming/lab1/#launch-an-example","title":"Launch an example","text":"<ul> <li>Access the Wokwi simulation environment via this link.</li> <li> <p>Select the ESP32 template.</p> <p> </p> <p>Warning</p> <p>Open the ESP32 template from <code>Starter Templates</code>, not from <code>ESP-IDF Templates</code>. The former is based on the Arduino IDE while the latter is based on the ESP-IDF environment that will not be used in the course.</p> </li> <li> <p>Simulate the example sketch:</p> <pre><code>void setup() {\n// put your setup code here, to run once:\nSerial.begin(115200);\nSerial.println(\"Hello, ESP32!\");\n}\n\nvoid loop() {\n// put your main code here, to run repeatedly:\ndelay(10); // this speeds up the simulation\n}\n</code></pre> <p>Warning</p> <p>Here you are simulating the behavior of the system including the code, you are not compiling the code (i.e., we're not generating the machine-readable code that will be executed by a processor). But the code MUST be compliable (i.e., it will be verified to check that I would compile )</p> <p>Info</p> <ul> <li>Note that the real-time factor at the top right corner should be as close as possible to 100%. This value is a simulation performance metric. The closer it gets to 100%, the better is the simulation. A value of 100% means the simulation is running in real-time. If the value drops, the times in the simulation are no longer reliable.</li> <li>Note the instruction <code>delay(10); // this speeds up the simulation</code>. Try to comment this line and see what happens. What if you put <code>delay(1);</code> or <code>delay(5);</code>?</li> </ul> <p>Question</p> <ul> <li>What is the purpose of the <code>setup()</code> function?</li> <li>What is the purpose of the <code>loop()</code> function?</li> <li>What does the <code>delay()</code> function do?</li> <li>Why do we need to put the <code>delay(10)</code> inside the <code>loop()</code> function?</li> </ul> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#add-hardware-components","title":"Add hardware components","text":"<ul> <li> <p>First of all, check the <code>diagram.json</code> file . What information do you see there?</p> </li> <li> <p>Connect an LED to <code>GPIO 21</code> with a resistor, as shown in the diagram (rotate - R and flip - P components if necessary).</p> <p></p> <p>Question</p> <ul> <li>Check again the <code>diagram.json</code>. What happened? Can you change the color of the LED to green from this file?</li> <li>What do you think you can do with the Library Manager?</li> </ul> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#22-turn-an-led-on-and-off","title":"2.2. Turn an LED ON and OFF","text":"<p>Connect an LED as follows:</p> <p></p> <p>Run the following program: </p><pre><code>#define LED_PIN 21\n#define BUTTON_PIN 35\n\nvoid setup() {\n    pinMode(LED_PIN, OUTPUT);\n    pinMode(BUTTON_PIN, INPUT_PULLUP);\n}\n\nvoid loop() {\n    digitalWrite(LED_PIN, HIGH);\n    delay(500);\n    digitalWrite(LED_PIN, LOW);\n    delay(500);\n}\n</code></pre>"},{"location":"microcontrollers_programming/lab1/#23-control-the-led-state-with-a-push-button","title":"2.3. Control the LED state with a push button","text":"<ul> <li> <p>Implement the circuit shown in the following diagram and simulate a program that:</p> <ul> <li>Turns the LED ON when the button is pressed.</li> <li>Turns the LED OFF when the button is not pressed.</li> </ul> <p>Tip</p> <ul> <li>Use the function <code>digitalRead()</code> to get the status of the button.</li> <li>You may need to use the <code>if...else</code> condition.</li> </ul> <p></p> <p>Warning</p> <p>When you place the button, don\u2019t forget to deselect the bounce option to avoid bouncing issues.</p> <p></p> <p>Question</p> <ul> <li>What information is included in the <code>diagram.json</code>? Did it change with respect to the previous exercise?  </li> <li>Can you do the exercise without using the <code>if...else</code> condition? How?</li> </ul> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#24-additional-exercises","title":"2.4. Additional exercises","text":""},{"location":"microcontrollers_programming/lab1/#241-blink","title":"2.4.1. Blink","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED while the button is pushed.</p> <p>Tip</p> <p>You may need to use the <code>millis()</code> function.</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#242-short-press-vs-long-press","title":"2.4.2. Short press vs long press","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that does the following:</p> <ul> <li>Short press (&lt; 500 ms): Toggle LED (if the LED is ON, turns it OFF, and viceversa).</li> <li>Long press (\u2265 500 ms): Blink LED.</li> </ul> <p>Tip</p> <p>You may need to use the <code>millis()</code> function, and the  <code>if...else</code> condition.</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/","title":"Sesi\u00f3n de Laboratorio 1: Introducci\u00f3n a la programaci\u00f3n de microcontroladores","text":""},{"location":"microcontrollers_programming/lab1/spanish/#sesion-de-laboratorio-1-introduccion-a-la-programacion-de-microcontroladores","title":"Sesi\u00f3n de Laboratorio 1: Introducci\u00f3n a la programaci\u00f3n de microcontroladores","text":"<p>Tiempo estimado: 1.5h (1 sesi\u00f3n)</p>"},{"location":"microcontrollers_programming/lab1/spanish/#1-trabajando-con-hardware-real","title":"1. Trabajando con hardware real","text":""},{"location":"microcontrollers_programming/lab1/spanish/#11-preparar-el-ide-de-arduino","title":"1.1. Preparar el IDE de Arduino","text":"<p>Sigue los pasos de instalaci\u00f3n descritos en esta gu\u00eda.</p> <ol> <li>Instala el IDE de Arduino: Desc\u00e1rgalo desde este enlace:</li> <li> <p>Instala la familia de placas M5Stack:</p> <p></p> <p>Necesitas copiar/pegar este texto para descargar el paquete de placas:</p> <pre><code>https://static-cdn.m5stack.com/resource/arduino/package_m5stack_index.json \n</code></pre> <p></p> <p>Una vez configurada la direcci\u00f3n del paquete, puedes instalarlo desde el gestor de placas.</p> <p></p> <p>IMPORTANTE: Recuerda instalar la versi\u00f3n 2.1.4. Si intentas instalar la versi\u00f3n 3.X, no podr\u00e1s realizar los ejercicios de las sesiones de laboratorio. M\u00e1s adelante hablaremos sobre las versiones 2.X y 3.X y c\u00f3mo migrar nuestro c\u00f3digo de una a otra. Por ahora, utiliza \u00fanicamente la versi\u00f3n 2.X.</p> <p>IMPORTANTE: Una vez que hayas hecho esto, si m\u00e1s adelante abres el Arduino IDE, aparecer\u00e1 un mensaje inform\u00e1ndote de que hay actualizaciones disponibles para algunas bibliotecas y pregunt\u00e1ndote si deseas instalarlas o no.     No actualices las bibliotecas.</p> <p>INFO: Este proceso puede tardar unos minutos.</p> <p>Una vez instalado, puedes seleccionar M5Core2 desde el men\u00fa de selecci\u00f3n de placas.</p> <p></p> </li> <li> <p>Instala las librer\u00edas de Arduino para M5Core2:</p> <p></p> <p>NOTA: Cuando pulses Install, ver\u00e1s la lista de dependencias. DEBES instalar tambi\u00e9n todas las dependencias.</p> <p>INFO: Este es un proceso largo que puede tardar varios minutos. Ten paciencia...</p> <p>AYUDA: Si la lista de dependencias es tan grande que no puedes ver el bot\u00f3n Install All, puedes pulsar la tecla tabulador dos veces para poner el cursor sobre el bot\u00f3n y luego pulsar Enter* para instalar todas las dependencias.</p> </li> <li> <p>Instala el driver CP2104 (controlador USB):</p> <ul> <li>Enlace para Windows</li> <li>Enlace para MacOS</li> <li>Enlace para Linux</li> </ul> <p>M\u00e1s informaci\u00f3n sobre la instalaci\u00f3n del controlador USB aqu\u00ed.</p> <p>Ahora, cuando conectes el dispositivo M5Core2 al PC con el cable USB, podr\u00e1s seleccionar el puerto en el IDE de Arduino. </p> <p>INFO:  - En Windows, el puerto se llama COMX, donde X es un n\u00famero que puede variar, por ejemplo, COM5.  - En Linux, el puerto se llama \"ttyUSBX\" o \"ttyACMX\", donde X es un n\u00famero que puede variar, por ejemplo, ttyUSB2.</p> </li> <li> <p>Compila y sube el ejemplo <code>hello_world.ino</code> de la librer\u00eda M5Core2:</p> <p></p> <p>Puedes pulsar el bot\u00f3n Upload (en rojo) para compilar y cargar el programa en el dispositivo. Observa que el bot\u00f3n de la izquierda (Verify - en verde) compila el programa pero no lo sube al dispositivo.</p> <p></p> </li> <li> <p>OPCIONAL (hazlo SOLO si has terminado todos los ejercicios de la sesi\u00f3n): Puedes abrir otros ejemplos si quieres ver el potencial del M5Core2. Por ejemplo:</p> <p></p> </li> </ol> <p>AYUDA: \"Recursos adicionales\"     Aqu\u00ed puedes encontrar m\u00e1s documentaci\u00f3n sobre algunas funciones b\u00e1sicas del M5Core2.</p> <p>Pinout y notas importantes A continuaci\u00f3n se muestra el pinout del M5Core2. Los pines marcados en rojo son los que usaremos en los ejercicios.</p> <p></p> <p>NOTA:  - Algunos pines del M5Core2 est\u00e1n preconfigurados, as\u00ed que presta atenci\u00f3n al conectar componentes externos.  - El ESP32 dentro del M5Core2 tiene 3 puertos serie:    - <code>Serial1</code> est\u00e1 reservado para la pantalla (no lo uses).    - <code>Serial0</code> se puede configurar (pines <code>G3 \u2013 RXD0</code> y <code>G1 \u2013 TXD0</code>), pero est\u00e1 reservado para la conexi\u00f3n USB al PC.    - <code>Serial2</code> est\u00e1 libre y se puede configurar (pines G13 \u2013 RXD2 y G14 \u2013 TXD2) como GPIO normales usando <code>pinMode()</code>.</p>"},{"location":"microcontrollers_programming/lab1/spanish/#12-encender-y-apagar-un-led","title":"1.2. Encender y apagar un LED","text":"<p>Conecta un LED como se muestra:</p> <p></p> <p>Ejecuta el siguiente programa: </p><pre><code>#include &lt;M5Core2.h&gt;\n#define LED_PIN 14\n\nvoid setup() {\n  M5.begin(); // Initialize M5Core2\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(LED_PIN, HIGH);\n  delay(500);\n  digitalWrite(LED_PIN, LOW);\n  delay(500);\n}\n</code></pre> <p>PREGUNTA:</p> <ul> <li>\u00bfQu\u00e9 hace <code>#define</code>?</li> <li>\u00bfQu\u00e9 hace la funci\u00f3n <code>pinMode()</code>?</li> <li>\u00bfQu\u00e9 hace la funci\u00f3n <code>digitalWrite()</code>?</li> </ul> <p>PREGUNTA:</p> <ul> <li>Te habr\u00e1s dado cuenta de que has tenido que incluir <code>#include &lt;M5Core2.h&gt;</code> y <code>M5.begin(); // Initialize M5Core</code> \u00bfPor qu\u00e9 tuviste que hacerlo? \u00bfPara qu\u00e9 sirven estas instrucciones?</li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/#13-ejercicios-adicionales","title":"1.3. Ejercicios adicionales","text":""},{"location":"microcontrollers_programming/lab1/spanish/#131-parpadear-a-una-cierta-frecuencia","title":"1.3.1. Parpadear a una cierta frecuencia","text":"<ul> <li>Usando el mismo circuito del ejercicio anterior, escribe un script que haga parpadear el LED a una frecuencia de 10 Hz.</li> </ul> <p>PREGUNTA:</p> <ul> <li>\u00bfDurante cu\u00e1nto tiempo debe estar ENCENDIDO o APAGADO el LED en cada ciclo?</li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/#132-parpadear-y-detener","title":"1.3.2. Parpadear y detener","text":"<ul> <li>Usando el mismo circuito del ejercicio anterior, escribe un script que haga parpadear el LED a una frecuencia de 2 Hz y detenga el parpadeo despu\u00e9s de 5 segundos.</li> </ul> <p>PREGUNTA:</p> <ul> <li>\u00bfCu\u00e1ntas veces parpadea el LED?</li> <li>\u00bfCu\u00e1l es el estado final del LED cuando se detiene el parpadeo, permanece ENCENDIDO o APAGADO?</li> </ul> <p>PISTA:</p> <ul> <li>Puede que necesites usar el bucle <code>for</code>, o la condici\u00f3n <code>if...else</code>.</li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/#2-trabajando-en-simulacion","title":"2. Trabajando en simulaci\u00f3n","text":""},{"location":"microcontrollers_programming/lab1/spanish/#21-simulacion-de-microcontroladores","title":"2.1. Simulaci\u00f3n de microcontroladores","text":""},{"location":"microcontrollers_programming/lab1/spanish/#ejecutar-un-ejemplo","title":"Ejecutar un ejemplo","text":"<ul> <li>Accede al entorno de simulaci\u00f3n Wokwi a trav\u00e9s de este enlace.</li> <li> <p>Selecciona la plantilla ESP32.</p> <p> </p> <p>NOTA: Abre la plantilla ESP32 desde <code>Starter Templates</code>, no desde <code>ESP-IDF Templates</code>. La primera est\u00e1 basada en el IDE de Arduino, mientras que la segunda est\u00e1 basada en el entorno ESP-IDF que no se usar\u00e1 en el curso.</p> </li> <li> <p>Simula el sketch de ejemplo:</p> <pre><code>void setup() {\n// c\u00f3digo de configuraci\u00f3n, se ejecuta una sola vez:\nSerial.begin(115200);\nSerial.println(\"Hello, ESP32!\");\n}\n\nvoid loop() {\n// c\u00f3digo principal, se ejecuta repetidamente:\ndelay(10); // esto acelera la simulaci\u00f3n\n}\n</code></pre> <p>NOTA: Aqu\u00ed est\u00e1s simulando el comportamiento del sistema, incluido el c\u00f3digo; no est\u00e1s compilando el c\u00f3digo (es decir, no se est\u00e1 generando el c\u00f3digo m\u00e1quina que ejecutar\u00e1 un procesador). Pero el c\u00f3digo DEBE ser compilable (es decir, se verificar\u00e1 que podr\u00eda compilar).</p> <p>INFO: - Observa que el factor de tiempo real en la esquina superior derecha debe estar lo m\u00e1s cerca posible del 100%. Este valor es una m\u00e9trica de rendimiento de la simulaci\u00f3n. Cuanto m\u00e1s cerca est\u00e9 de 100%, mejor ser\u00e1 la simulaci\u00f3n. Un valor del 100% significa que la simulaci\u00f3n se ejecuta en tiempo real. Si el valor baja, los tiempos de la simulaci\u00f3n dejan de ser fiables. - Observa la instrucci\u00f3n <code>delay(10); // esto acelera la simulaci\u00f3n</code>. Prueba a comentar esta l\u00ednea y observa qu\u00e9 ocurre. \u00bfQu\u00e9 pasa si pones <code>delay(1);</code> o <code>delay(5);</code>?</p> <p>PREGUNTA: - \u00bfCu\u00e1l es el prop\u00f3sito de la funci\u00f3n setup()? - \u00bfCu\u00e1l es el prop\u00f3sito de la funci\u00f3n loop()? - \u00bfQu\u00e9 hace la funci\u00f3n delay()? - \u00bfPor qu\u00e9 necesitamos poner delay(10) dentro de la funci\u00f3n loop()?</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/#anadir-componentes-de-hardware","title":"A\u00f1adir componentes de hardware","text":"<ul> <li> <p>Primero, revisa el archivo <code>diagram.json</code>. \u00bfQu\u00e9 informaci\u00f3n tiene?</p> </li> <li> <p>Conecta un LED al <code>GPIO 21</code> con una resistencia, como se muestra en el diagrama (rota - tecla R y voltea - tecla P los componentes si es necesario).</p> <p></p> <p>PREGUNTA: - Revisa de nuevo el <code>diagram.json</code>. \u00bfQu\u00e9 ha cambiado? \u00bfPuedes cambiar el color del LED a verde desde este archivo? - \u00bfQu\u00e9 crees que puedes hacer con el Library Manager?</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/#22-encender-y-apagar-un-led","title":"2.2. Encender y apagar un LED","text":"<p>Conecta un LED como se muestra:</p> <p></p> <p>Ejecuta el siguiente programa: </p><pre><code>#define LED_PIN 21\n#define BUTTON_PIN 35\n\nvoid setup() {\n    pinMode(LED_PIN, OUTPUT);\n    pinMode(BUTTON_PIN, INPUT_PULLUP);\n}\n\nvoid loop() {\n    digitalWrite(LED_PIN, HIGH);\n    delay(500);\n    digitalWrite(LED_PIN, LOW);\n    delay(500);\n}\n</code></pre>"},{"location":"microcontrollers_programming/lab1/spanish/#23-controlar-el-estado-del-led-con-un-pulsador","title":"2.3. Controlar el estado del LED con un pulsador","text":"<ul> <li>Implementa el circuito mostrado en el siguiente diagrama y simula un programa que:<ul> <li>Encienda el LED cuando se pulse el bot\u00f3n.</li> <li>Apague el LED cuando el bot\u00f3n no est\u00e9 pulsado.</li> </ul> </li> </ul> <p>PISTA:</p> <ul> <li>Usa la funci\u00f3n <code>digitalRead()</code> para obtener el estado del bot\u00f3n.</li> <li>Puede que necesites usar la condici\u00f3n <code>if...else</code>.</li> </ul> <p></p> <p>INFO:</p> <ul> <li>Al colocar el bot\u00f3n, no olvides deseleccionar la opci\u00f3n bounce para evitar problemas de rebotes.</li> </ul> <p></p> <p>PREGUNTA:</p> <ul> <li>\u00bfQu\u00e9 informaci\u00f3n se incluye en el <code>diagram.json</code>? \u00bfCambi\u00f3 con respecto al ejercicio anterior?  </li> <li>\u00bfSe puede hacer el ejercicio sin usar la condici\u00f3n <code>if...else</code>? \u00bfC\u00f3mo?</li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/#24-ejercicios-adicionales","title":"2.4. Ejercicios adicionales","text":""},{"location":"microcontrollers_programming/lab1/spanish/#241-parpadear","title":"2.4.1. Parpadear","text":"<ul> <li>Usando el mismo circuito del ejercicio anterior, escribe un script que haga parpadear el LED mientras se mantiene pulsado el bot\u00f3n.</li> </ul> <p>PISTA:</p> <ul> <li>Puede que necesites usar la funci\u00f3n <code>millis()</code>.</li> </ul>"},{"location":"microcontrollers_programming/lab1/spanish/#242-pulsacion-corta-vs-pulsacion-larga","title":"2.4.2. Pulsaci\u00f3n corta vs pulsaci\u00f3n larga","text":"<ul> <li>Usando el mismo circuito del ejercicio anterior, escribe un script que haga lo siguiente:<ul> <li>Pulsaci\u00f3n corta (&lt; 500 ms): Alternar el LED (si el LED est\u00e1 ENCENDIDO, apagarlo, y viceversa).</li> <li>Pulsaci\u00f3n larga (\u2265 500 ms): Hacer parpadear el LED.</li> </ul> </li> </ul> <p>PISTA:</p> <ul> <li>Puede que necesites usar la funci\u00f3n <code>millis()</code> y la condici\u00f3n <code>if...else</code>.</li> </ul>"},{"location":"microcontrollers_programming/lab2/","title":"Lab Session 2: Timers","text":""},{"location":"microcontrollers_programming/lab2/#lab-session-2-timers","title":"Lab Session 2: Timers","text":"<p>Estimated time: 1.5h (1 session)</p> <p>Description</p> <p>The goal of this session is to learn the different ways a microcontroller can perform timing operations. As seen previously, the <code>delay()</code> function can be used to create a wait for the required amount of time. However, to solve slightly more complex problems, it becomes necessary to use timers, which allow us to interrupt the normal execution of the program in order to handle a periodic event.</p>"},{"location":"microcontrollers_programming/lab2/#1-working-with-real-hardware","title":"1. Working with real hardware","text":""},{"location":"microcontrollers_programming/lab2/#11-using-an-external-library-ticker","title":"1.1. Using an external library - Ticker","text":"<p>The Arduino Ticker Library allows you to create easily Ticker callbacks, which can call a function in a predetermined interval The following example shows how to perform timing operations using the Ticker library and the <code>attach()</code> or <code>attach_ms()</code> functions.</p> <pre><code>#include &lt;M5Core2.h&gt;   // M5Stack Core2 library\n#include &lt;Ticker.h&gt;    // Ticker library\n\n#define LED_PIN 14     // GPIO pin where the LED is connected on the M5Core2\n\nTicker blinker;        // Create a Ticker object. It will call a function at regular intervals.\n\n/*\n  This function (callback) will be called by the Ticker at the configured time interval.\n  It simply toggles the LED state:\n    - digitalRead(LED_PIN) reads the current state (HIGH/LOW)\n    - ! inverts that state\n    - digitalWrite writes the inverted state back to the pin\n*/\nvoid changeState()\n{\n    digitalWrite(LED_PIN, !(digitalRead(LED_PIN))); \n}\n\nvoid setup() \n{\n    M5.begin();          // Initialize the M5Core2 hardware (display, I2C, etc.)\n    pinMode(LED_PIN, OUTPUT); // Configure the LED pin as an output\n\n    // Initialize the Ticker to call changeState() periodically.\n    // attach() accepts time in seconds (here 0.5 s = 500 ms).\n    // If you prefer milliseconds, use attach_ms(milliseconds, callback).\n    blinker.attach(0.5, changeState); \n}\n\nvoid loop() \n{      \n    // Empty: the Ticker handles the periodic LED toggling asynchronously.\n}\n</code></pre> <p>Connect an LED to pin 14 of the M5Core2 and modify this example so that the LED blinks every second instead of every 500 ms.</p> <p></p>"},{"location":"microcontrollers_programming/lab2/#12-use-hardware-timers","title":"1.2. Use hardware timers","text":"<p>However, as stated in the Ticker library documentation, \"The library use no interupts of the hardware timers and works with the micros() / millis() function.\" This means that our ability to develop an application using different timer configurations or to implement multitasking applications would be highly limited if we restrict ourselves to using this library.</p> <p>Perform the previous exercise again, but in this case use an interrupt generated directly by the timer, and configure it so that the LED turns ON and OFF every second. Verify with a watch that it works correctly.</p>"},{"location":"microcontrollers_programming/lab2/#2-working-in-simulation","title":"2. Working in simulation","text":"<p>You can do exactly the same exercises in simulation. Just use the same circuit with the LED we used in the previous lab sessions.</p>"},{"location":"microcontrollers_programming/lab2/spanish/","title":"Sesi\u00f3n de Laboratorio 2: Temporizadores","text":""},{"location":"microcontrollers_programming/lab2/spanish/#sesion-de-laboratorio-2-temporizadores","title":"Sesi\u00f3n de Laboratorio 2: Temporizadores","text":"<p>Tiempo estimado: 1.5h (1 sesi\u00f3n)</p> <p>Descripci\u00f3n</p> <p>El objetivo de esta sesi\u00f3n es aprender las diferentes formas en que un microcontrolador puede realizar operaciones de temporizaci\u00f3n. Como se vio anteriormente, la funci\u00f3n <code>delay()</code> se puede utilizar para crear una espera durante el tiempo requerido. Sin embargo, para resolver problemas ligeramente m\u00e1s complejos, se vuelve necesario utilizar temporizadores, que nos permiten interrumpir la ejecuci\u00f3n normal del programa para manejar un evento peri\u00f3dico.</p>"},{"location":"microcontrollers_programming/lab2/spanish/#1-trabajando-con-hardware-real","title":"1. Trabajando con hardware real","text":""},{"location":"microcontrollers_programming/lab2/spanish/#11-usando-una-biblioteca-externa-ticker","title":"1.1. Usando una biblioteca externa - Ticker","text":"<p>La Biblioteca Ticker de Arduino permite crear f\u00e1cilmente callbacks de Ticker, que pueden llamar a una funci\u00f3n en un intervalo predeterminado. El siguiente ejemplo muestra c\u00f3mo realizar operaciones de temporizaci\u00f3n utilizando la biblioteca Ticker y las funciones <code>attach()</code> o <code>attach_ms()</code>.</p> <pre><code>#include &lt;M5Core2.h&gt;   // M5Stack Core2 library\n#include &lt;Ticker.h&gt;    // Ticker library\n\n#define LED_PIN 14     // GPIO pin where the LED is connected on the M5Core2\n\nTicker blinker;        // Create a Ticker object. It will call a function at regular intervals.\n\n/*\n  This function (callback) will be called by the Ticker at the configured time interval.\n  It simply toggles the LED state:\n    - digitalRead(LED_PIN) reads the current state (HIGH/LOW)\n    - ! inverts that state\n    - digitalWrite writes the inverted state back to the pin\n*/\nvoid changeState()\n{\n    digitalWrite(LED_PIN, !(digitalRead(LED_PIN))); \n}\n\nvoid setup() \n{\n    M5.begin();          // Initialize the M5Core2 hardware (display, I2C, etc.)\n    pinMode(LED_PIN, OUTPUT); // Configure the LED pin as an output\n\n    // Initialize the Ticker to call changeState() periodically.\n    // attach() accepts time in seconds (here 0.5 s = 500 ms).\n    // If you prefer milliseconds, use attach_ms(milliseconds, callback).\n    blinker.attach(0.5, changeState); \n}\n\nvoid loop() \n{      \n    // Empty: the Ticker handles the periodic LED toggling asynchronously.\n}\n</code></pre> <p>Conecta una LED al pin 14 del M5Core2 y modifica este ejemplo para que la LED parpadee cada segundo en lugar de cada 500 ms.</p> <p></p>"},{"location":"microcontrollers_programming/lab2/spanish/#12-usar-temporizadores-de-hardware","title":"1.2. Usar temporizadores de hardware","text":"<p>Sin embargo, como se indica en la documentaci\u00f3n de la biblioteca Ticker, \"La biblioteca no utiliza interrupciones de los temporizadores de hardware y funciona con las funciones micros() / millis()\". Esto significa que nuestra capacidad para desarrollar una aplicaci\u00f3n utilizando diferentes configuraciones de temporizador o para implementar aplicaciones multitarea estar\u00eda muy limitada si nos restringimos a usar esta biblioteca.</p> <p>Realiza el ejercicio anterior nuevamente, pero en este caso utiliza una interrupci\u00f3n generada directamente por el temporizador y config\u00faralo para que la LED se encienda y apague cada segundo. Verifica con un reloj que funcione correctamente.</p>"},{"location":"microcontrollers_programming/lab2/spanish/#2-trabajando-en-simulacion","title":"2. Trabajando en simulaci\u00f3n","text":"<p>Puedes realizar exactamente los mismos ejercicios en simulaci\u00f3n. Simplemente utiliza el mismo circuito con la LED que usamos en las sesiones de laboratorio anteriores.</p>"},{"location":"microcontrollers_programming/lab3/","title":"Lab Session 3: PWM","text":""},{"location":"microcontrollers_programming/lab3/#lab-session-3-pwm","title":"Lab Session 3: PWM","text":"<p>Estimated time: 1.5 h (1 session)</p>"},{"location":"microcontrollers_programming/lab3/#description","title":"Description","text":"<p>The goal of this lab session is to understand the generation and use of PWM signals, as well as controlling a DC motor using these signals. For this lab you have a DC motor, a motor driver based on the L298N H-bridge, and an M5Core2.</p>"},{"location":"microcontrollers_programming/lab3/#1-working-with-real-hardware","title":"1. Working with real hardware","text":""},{"location":"microcontrollers_programming/lab3/#part-1-generating-pwm-with-an-led","title":"Part 1 - Generating PWM with an LED","text":"<p>Perform a test that generates a PWM signal to vary the brightness of an LED connected to pin 14 of the M5Core2. This tutorial explains how to do it.</p> <p>The LED must smoothly increase brightness from completely off (0% PWM) to fully on (100% PWM). Once at 100%, it must smoothly dim back down to 0% PWM. Both the rising and falling phases should follow a \"ramp\" profile, like the figure below:</p> <p></p>"},{"location":"microcontrollers_programming/lab3/#part-2-generating-pwm-for-a-dc-motor","title":"Part 2 - Generating PWM for a DC motor","text":"<p>The image below shows the connector layout of the motor driver:</p> <p></p> <p>This driver can control up to two DC motors simultaneously. In the previous image, the green ports correspond to motor A and the yellow ports to motor B.</p> <p>Wire the M5Core2 to the L298N motor driver as follows:</p> <ul> <li><code>GPIO14</code> to <code>IN1</code> on the driver. This PWM output will set the power for the positive rotation direction (counterclockwise).</li> <li><code>GPIO13</code> to <code>IN2</code> on the driver. This PWM output will set the power for the negative rotation direction (clockwise).</li> <li>Connect <code>GND</code> and <code>VS</code> (on the driver) to a 9\u201312 V power supply.</li> <li>Connect <code>GND</code> (M5Core2) to <code>GND</code> (driver). It is essential to share grounds; otherwise the PWM signal reference is undefined.</li> <li>Connect the motor to the motor A terminals on the driver.</li> <li>Ensure the <code>ENA</code> pin on the driver is powered/enabled; otherwise motor A output will be disabled. The driver includes a jumper that can power <code>ENA</code> from its onboard 5 V regulator.</li> </ul> <p>A simple tutorial on using this driver can be found here.</p> <p>After wiring the microcontroller to the motor, modify the tutorial code so that the motor accelerates in the positive direction from 0% PWM to 100% PWM, then decelerates from 100% back to 0% PWM. After completing accelerate/decelerate in the positive direction, repeat the same sequence in the negative direction, then loop this sequence indefinitely. The profile should be similar to the following image:</p> <p></p> <p>Question</p> <ul> <li>What happens when the PWM frequency is changed? Test frequencies between 1 kHz and 10 kHz.</li> <li>What happens when the PWM resolution is changed? Test resolutions between 8 and 10 bits.</li> <li>If the resolution is changed, is any other code change required or is it sufficient to update the resolution value passed to ledcSetup?</li> </ul>"},{"location":"microcontrollers_programming/lab3/#2-working-in-simulation","title":"2. Working in simulation","text":""},{"location":"microcontrollers_programming/lab3/#part-1-generating-pwm-with-an-led_1","title":"Part 1 - Generating PWM with an LED","text":"<p>This exercise can be performed the same way in simulation as on real hardware.</p>"},{"location":"microcontrollers_programming/lab3/#part-2-generating-pwm-for-a-dc-motor_1","title":"Part 2 - Generating PWM for a DC motor","text":"<p>This exercise cannot be performed exactly the same in simulation because Wokwi does not include a DC motor component. However, there are ways to prototype motor code in simulation.</p> <p>A simple approach is to use two LEDs: LED1 simulates the motor behavior when rotating clockwise, and LED2 simulates rotation counterclockwise. Program the PWM signals for both LEDs in the same way you would for IN1 and IN2 on the driver. This lets you validate the PWM logic that will be used for the real motor.</p> <p>Info</p> <ul> <li>To verify correct operation, ensure both simulated motor LEDs are never on at the same time.</li> </ul> <p>Tip</p> <ul> <li>When using PWM in Wokwi, real-time performance may degrade significantly if many PWM updates occur each loop iteration. To avoid this, change duty cycle in steps every several loop iterations or add a sufficiently large delay between updates. I.e., use a steps-like signal instead of a ramp-like signal.</li> </ul>"},{"location":"microcontrollers_programming/lab3/spanish/","title":"Lab Session 3: PWM","text":""},{"location":"microcontrollers_programming/lab3/spanish/#lab-session-3-pwm","title":"Lab Session 3: PWM","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"microcontrollers_programming/lab3/spanish/#descripcion","title":"Descripci\u00f3n","text":"<p>El objetivo de esta pr\u00e1ctica es entender la generaci\u00f3n y uso de las se\u00f1ales PWM, as\u00ed como el control de un motor utilizando este tipo de se\u00f1ales. Para esto, se cuenta con un motor de Corriente Continua (CC o DC - Direct Current - en ingl\u00e9s), una controladora de motores (tambi\u00e9n conocido com\u00fanmente como driver) basada en el puente H L298n, y un M5Core2.</p>"},{"location":"microcontrollers_programming/lab3/spanish/#1-trabajando-con-hardware-real","title":"1. Trabajando con hardware real","text":""},{"location":"microcontrollers_programming/lab3/spanish/#parte-1-generacion-de-pwm-con-led","title":"Parte 1 - Generaci\u00f3n de PWM con LED","text":"<p>Realizar una prueba de generaci\u00f3n de una se\u00f1al PWM para iluminar m\u00e1s o menos un LED conectado al pin 14 del M5Core2. Este tutorial explica c\u00f3mo se puede realizar.</p> <p>El LED se tiene que encender de forma progresiva desde el estado completamente apagado (PWM de 0%) hasta el estado completamente encendido (PWM de 100%). Una vez en el 100%, deber\u00e1 apagarse tambi\u00e9n de forma progresiva (desde un PWM de 100% hasta un PWM de 0%), siguiendo en ambos casos un perfil tipo \"rampa\", primero creciente y luego decreciente, como el de la siguiente figura:</p> <p></p>"},{"location":"microcontrollers_programming/lab3/spanish/#parte-2-generacion-de-pwm-con-motor-cc","title":"Parte 2 - Generaci\u00f3n de PWM con motor CC","text":"<p>La siguiente figura muestra la ubicaci\u00f3n de los conectores de la controladora:</p> <p></p> <p>Esta controladora permite controlar hasta 2 motores CC de forma simult\u00e1nea. En la figura anterior, los puertos en verde se corresponder\u00edan con el motor A y los amarillos con el motor B.</p> <p>Realizar el conexionado del M5Core2 con la controladora de motores (puente H L298N) de la siguiente manera:</p> <ul> <li>GPIO14 a pin IN1 en la controladora. Esta salida PWM permitir\u00e1 establecer la potencia del sentido de giro positivo (sentido contrario a las agujas del reloj).</li> <li>GPIO13 a pin IN2 en controladora. Esta salida PWM permitir\u00e1 establecer la potencia del sentido de giro negativo (sentido de las agujas del reloj).</li> <li>GND y VS (en controladora) conectado a una fuente de alimentaci\u00f3n de 9-12V.</li> <li>GND (M5Core2) a GND (Controladora). Es imprescindible conectar las masas de la controladora y del microcontrolador, de lo controlario no se conocer\u00eda la referencia de las se\u00f1ales PWM.</li> <li>Conectar el motor a la controladora en los terminales del motor A.</li> <li>Es imprescindible que el pin ENA de la controladora est\u00e9 alimentado, de lo contrario la salida del motor A estar\u00eda deshabilitada (para eso se dispone de un jumper que permite alimentar el pin ENA con el regulador de 5V que incluye el propio driver).</li> </ul> <p>Un tutorial sencillo sobre el uso de este driver puede encontrarse en este enlace</p> <p>Una vez conectado el microcontrolador con el motor, modificar el c\u00f3digo del tutorial, para que el motor gire acelerando en el sentido de giro positivo desde un PWM de 0% hasta uno de 100%, y luego decelerando desde el PWM de 100% hasta el 0%. Cuando se haya hecho la aceleraci\u00f3n y deceleraci\u00f3n en el sentido de giro positivo, se deber\u00e1 hacer lo mismo pero en sentido negativo de giro y seguir realizando esta secuencia de forma indefinida en el tiempo. Como se indica en la siguiente imagen:</p> <p></p> <p>PREGUNTA:</p> <ul> <li>\u00bfQu\u00e9 ocurre cuando se cambia la frecuencia del PWM? Probar con frecuencias entre 1 y 10 kHz.</li> <li>\u00bfQu\u00e9 ocurre cuando se cambia la resoluci\u00f3n del PWM? Probar con resoluciones entre 8 y 10 bits. </li> <li>Si se cambia la resoluci\u00f3n, \u00bfhay que cambiar algo m\u00e1s del c\u00f3digo o basta con cambiar el valor de la resoluci\u00f3n en la funci\u00f3n <code>ledcSetup</code>?</li> </ul>"},{"location":"microcontrollers_programming/lab3/spanish/#2-trabajando-en-simulacion","title":"2. Trabajando en simulaci\u00f3n","text":""},{"location":"microcontrollers_programming/lab3/spanish/#parte-1-generacion-de-pwm-con-led_1","title":"Parte 1 - Generaci\u00f3n de PWM con LED","text":"<p>El ejercicio se puede realizar exactamente igual en simulaci\u00f3n y en real.</p>"},{"location":"microcontrollers_programming/lab3/spanish/#parte-2-generacion-de-pwm-con-motor-cc_1","title":"Parte 2 - Generaci\u00f3n de PWM con motor CC","text":"<p>Este ejercicio no se puede realizar igual en simulaci\u00f3n que en real porque en wokwi no existe el componente de motor de corriente continua. Sin embargo, existen varias formas de trabajar en simulaci\u00f3n para hacer el prototipado del c\u00f3digo para el motor.</p> <p>Una forma sencilla ser\u00eda utilizar 2 LEDs, donde el LED1 simular\u00eda el comportamiento del motor cuando gira en sentido horario, mientras el LED2 simular\u00eda el comportamiento del motor cuando gira en sentido antihorario. De esta forma, se pueden programar las se\u00f1ales PWM de ambos LEDs de forma similar a las se\u00f1ales PWM que se van a enviar a IN1 e IN2 en la controladora (que har\u00e1n que el motor gire en sentido horario o antihorario).</p> <p>INFO:</p> <ul> <li>Para comprobar el correcto funcionamiento del c\u00f3digo, es muy importante comporbar que ambos LEDs no est\u00e1n encendidos a la vez.</li> </ul> <p>PISTA:</p> <ul> <li>Al trabajar con PWM en wokwi, el factor de tiempo real puede disminuir considerablemnte, especialmente si se generan varias PWMs y se cambia el ciclo de trabajo en cada paso del loop. Para evitar esto, es aconsejable cambiar el ciclo de trabajo de forma escalonada cada varios varios pasos del loop o con un tiempo de espera lo suficientemente grande.</li> </ul>"},{"location":"microcontrollers_programming/lab4/","title":"Lab Session 4: Encoder","text":""},{"location":"microcontrollers_programming/lab4/#lab-session-4-encoder","title":"Lab Session 4: Encoder","text":"<p>Estimated time: 1.5 h (1 session)</p>"},{"location":"microcontrollers_programming/lab4/#description","title":"Description","text":"<p>To know the angular position of a motor shaft, incremental encoders are commonly used. The objective of this lab is to program the reading of this kind of sensor so we can know the exact position (subject to the encoder resolution) of the motor shaft at any instant.</p> <p>An incremental encoder usually provides 4 signals:</p> <ul> <li>GND: Ground.</li> <li>Vcc: Supply (3\u20135 V).</li> <li>Channel A: Encoder channel A.</li> <li>Channel B: Encoder channel B.</li> </ul> <p>Warning</p> <p>In the lab, the encoder is powered directly from an internal 5 V regulator provided by the equipment electronics. That means it is not necessary to power the encoder externally. However, GND must be considered as the reference for the A and B signals.</p> <p>If you connect both channels to an oscilloscope and rotate the motor shaft, you will see signals like those in the image:</p> <p></p> <p>Warning</p> <p>If the shaft is not moved, the signals will not change.</p>"},{"location":"microcontrollers_programming/lab4/#working-with-real-hardware","title":"Working with real hardware","text":""},{"location":"microcontrollers_programming/lab4/#part-1-signal-identification","title":"Part 1 - Signal identification","text":"<p>Connect the oscilloscope to the encoder and identify the colour of each signal on the motor to be used. Record this colour-to-signal mapping for later use with the microcontroller. Connect channels A and B and ground to the oscilloscope and verify that the responses match the image above. It is recommended to use the oscilloscope Run/Stop button to freeze the waveform while the motor is turning so you can inspect it.</p> <p>Connect the encoder ground (GND) to the microcontroller, and channels A and B to the digital inputs GPIO 27 and GPIO 19. This connection cannot be made directly as described below.</p> <p>Warning</p> <p>The encoder is powered at 5 V. That means the A and B signals, when high and unloaded, present 5 V. The ESP32 electronics works at 3.3 V, so you must not connect A and B directly to the microcontroller inputs. Use a voltage divider. Consider the encoder internal electronics (see image below).</p> <p></p> <p>The A and B channels already include a 3.3 k\u03a9 pull-up resistor. Therefore, to build the divider you only need to add the lower resistor of the divider.</p> <p></p> <p>Question</p> <p>What is the theoretical value of the resistor R to place as the lower resistor of the divider so that the channels A and B go from 5 V to 3.3 V when high?</p> <p>Assemble the circuit with the divider and verify with the oscilloscope that the high-level voltage on channels A and B does not exceed 3.3 V.</p>"},{"location":"microcontrollers_programming/lab4/#part-2-counting-encoder-pulses","title":"Part 2 - Counting encoder pulses","text":"<p>Develop Arduino code to count pulses generated by both signals. Store the count in a global variable and account for direction changes to increment or decrement the counter. Use interrupts on the digital inputs.</p> <p>To count pulses you must consider rising and/or falling edges of each channel and read the state of the other channel after the edge. For example: if there is a rising edge on A, and both A and B are high after the edge, rotation is in one direction (positive \u2014 increment the counter). If after a rising edge on A, A is high and B is low, rotation is in the opposite direction (negative \u2014 decrement the counter). The figure below shows an example where B leads A (rotation in one direction). If rotation reversed, A would lead B. You can verify this on the oscilloscope or by turning the motor by hand.</p> <p></p> <p>Example of an interrupt handler implementation:</p> <pre><code>void IRAM_ATTR ISR_Example()\n{\n  ...\n}\n</code></pre> <p>You can send the counter value over the Serial port as follows:</p> <pre><code>void setup()\n{\n  ...\n  Serial.begin(9600);\n}\n\nvoid loop()\n{\n  ...\n  Serial.println(counter);\n}\n</code></pre>"},{"location":"microcontrollers_programming/lab4/#part-3-pulses-per-revolution","title":"Part 3 - Pulses per revolution","text":"<p>Check the pulses per revolution produced by the encoder. Find this information in the motor/encoder technical details and verify experimentally with the real encoder.</p> <p>Question</p> <ul> <li>If only the rising edges of channel A are considered, how many pulses per revolution could we measure?</li> <li>What if rising edges of channels A and B are considered?</li> <li>What if rising and falling edges of channels A and B are considered?</li> </ul> <p>Question</p> <p>Could we send the position in degrees instead of encoder pulses over the serial port? How?</p>"},{"location":"microcontrollers_programming/lab4/#working-in-simulation","title":"Working in simulation","text":"<p>You can simulate an encoder in Wokwi using the Rotatory Encoder component: https://docs.wokwi.com/parts/wokwi-ky-040/. The simulation diagram would look like this:</p> <p></p> <p>Question</p> <p>What differences exist between the operation of this encoder and the encoder used with the motor in the lab?</p>"},{"location":"microcontrollers_programming/lab4/spanish/","title":"Lab Session 4: Enc\u00f3der","text":""},{"location":"microcontrollers_programming/lab4/spanish/#lab-session-4-encoder","title":"Lab Session 4: Enc\u00f3der","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"microcontrollers_programming/lab4/spanish/#descripcion","title":"Descripci\u00f3n","text":"<p>Para conocer la posici\u00f3n en la que se encuentra el eje de un motor se suelen emplear encoders incrementales. El objetivo de esta pr\u00e1ctica es la programaci\u00f3n de la lectura de este tipo de sensores, de manera que podamos conocer la posici\u00f3n exacta (asumiendo el error debido a la resoluci\u00f3n del propio sensor) en la que se encuentra el eje del motor en cada instante de tiempo.</p> <p>El encoder incremental, normalmente posee 4 se\u00f1ales:</p> <ul> <li>GND: Masa.</li> <li>Vcc: Alimentaci\u00f3n (3-5V).</li> <li>Canal A: Canal A del encoder</li> <li>Canal B: Canal B del encoder.</li> </ul> <p>IMPORTANTE: En la pr\u00e1ctica, el enc\u00f3der se alimenta directamente desde un regulador interno de 5V del que dispone la electr\u00f3nica del equipo. Eso quiere decir que no es necesario alimentar el enc\u00f3der externamente. Sin embargo, s\u00ed es necesario tener en cuenta GND como referencia para las se\u00f1ales recibidas por los canales A y B.</p> <p>Si conectamos estos dos canales a un osciloscopio y movemos el eje del motor, podremos apreciar que la se\u00f1al que se generan en estos dos canales es como la que se muestra en la imagen.</p> <p></p> <p>IMPORTANTE: Si no se mueve el eje del motor, no se ver\u00e1 ning\u00fan cambio en las se\u00f1ales.</p>"},{"location":"microcontrollers_programming/lab4/spanish/#trabajando-con-el-hardware-real","title":"Trabajando con el hardware real","text":""},{"location":"microcontrollers_programming/lab4/spanish/#parte-1-identificacion-de-senales","title":"Parte 1 - Identificaci\u00f3n de se\u00f1ales","text":"<p>Conectar el osciloscopio al encoder e identificar el color de cada una de se\u00f1ales descritas anteriormente en el motor que se va a emplear. Apuntar esta relaci\u00f3n color-se\u00f1al para poder usarla posteriormente con el microcontrolador. Conectar las se\u00f1ales de los canales A y B, as\u00ed como la masa al osciloscopio y comprobar que la respuesta de los dos canales es como la de la imagen anterior. Se recomienda utilizar el bot\u00f3n Run/Stop del osciloscopio para detener la lectura mientras el motor se encuentra girando y as\u00ed poder observarla bien.</p> <p>Conectar la masa del encoder (GND) al microcontrolador, y los canales A y B a las entradas digitales <code>GPIO 27</code> y <code>GPIO 19</code>. Esta conexi\u00f3n no se puede hacer directamente tal y como se describe a continuaci\u00f3n.</p> <p>IMPORTANTE: El enc\u00f3der est\u00e1 alimentado a una tensi\u00f3n de 5V. Eso quiere decir que las se\u00f1ales de los canales A y B en estado alto y sin carga externa proporcionan una tensi\u00f3n de 5V. Sin embargo, la electr\u00f3nica del ESP32 funciona a 3.3V. Es decir, no se deber\u00edan conectar los canales A y B a las entradas digitales del microcontrolador directamente. Para resolver este problema se puede utilizar un divisor de tensi\u00f3n. Para implementarlo, hay que tener en cuenta la electr\u00f3nica interna del enc\u00f3der (ver imagen siguiente).</p> <p></p> <p>Los canales A y B ya disponen de una resistencia pull-up de \\(3.3 k\\Omega\\). Por lo tanto, para realizar el divisor de tensi\u00f3n s\u00f3lo ser\u00e1 necesario incluir la resistencia de la parte baja del divisor de tensi\u00f3n.</p> <p></p> <p>PREGUNTA: \u00bfCu\u00e1l es el valor te\u00f3rico de la resistencia \\(R\\) que hay que colocar en la parte baja del divisor de tensi\u00f3n para que la tensi\u00f3n de los canales A y B pase de 5V a 3.3V cuando est\u00e9n en estado alto?</p> <p>Montar el circuito con el divisor de tensi\u00f3n y asegurarse midiendo con el osciloscopio que la tensi\u00f3n de los canales A y B en estado alto no supera los 3.3V.</p>"},{"location":"microcontrollers_programming/lab4/spanish/#parte-2-contador-de-pulsos-en-el-encoder","title":"Parte 2 - Contador de pulsos en el encoder","text":"<p>Desarrollar un c\u00f3digo Arduino que permita contar los pulsos generados por ambas se\u00f1ales. Almacenar esta cuenta en una variable global, y tener en cuenta los cambios de sentido para incrementar o decrementar el contador. Emplear las interrupciones de las entradas digitales para ello.</p> <p>Para contar los pulsos es necesario tener en cuenta los flancos de subida y/o de bajada de cada canal. Adem\u00e1s, ser\u00e1 necesario ver el estado de los canales despu\u00e9s del flanco. Por ejemplo: Si hay un flanco de subida de A, y tanto A como B est\u00e1n en estado alto, se est\u00e1 girando en un sentido (positivo, por ejemplo, por lo que hay que aumentar el contador). Si, por el contrario, despu\u00e9s del flanco de subida de A, A est\u00e1 en estado alto pero B est\u00e1 en bajo, significa que se est\u00e1 girando en sentido contrario (negativo, en este caso, por lo que habr\u00eda que disminuir el contador). A continuaci\u00f3n se representa un ejemplo en el que se est\u00e1 girando en un sentido determinado. Se puede ver c\u00f3mo la se\u00f1al B va \"adelantada\" a la A. Si se girase en sentido contrario, se ver\u00eda c\u00f3mo A \"adelanta\" a B. Esto se puede comprobar en el osciloscopio y el motor real gir\u00e1ndolo con la mano en un sentido u otro.</p> <p></p> <p>Ejemplo de implementaci\u00f3n de manejador de interrupci\u00f3n:</p> <pre><code>void IRAM_ATTR ISR_Ejemplo()\n{\n  ...  \n}\n</code></pre> <p>El valor del contador se puede enviar a trav\u00e9s del Puerto Serie de la siguiente forma:</p> <pre><code>void setup()\n{\n  ...  \n  Serial.begin(9600);\n}\n\nvoid loop()\n{\n  ...  \n  Serial.println(contador);\n}\n</code></pre>"},{"location":"microcontrollers_programming/lab4/spanish/#parte-3-contar-pulsos-por-vuelta","title":"Parte 3 - Contar pulsos por vuelta","text":"<p>Comprobar los pulsos por vueltas que genera el encoder. Buscar esta informaci\u00f3n en los detalles t\u00e9cnicos del motor y el encoder y comprobarlo con el enc\u00f3der real de forma experimental.</p> <p>PREGUNTA:   - Si se tienen en cuenta los flancos de subida del canal A, \u00bfcu\u00e1ntos pulsos por vuelta podr\u00edamos medir?    - \u00bfY si se tienen en cuenta los flancos de subida de los canales A y B?   - \u00bfY si se tienen en cuenta los flancos de subida y de bajada de los canales A y B?</p> <p>PREGUNTA: \u00bfPodr\u00edamos mandar la posici\u00f3n en grados en vez de en pulsos del enc\u00f3der por el puerto serie? \u00bfC\u00f3mo?</p>"},{"location":"microcontrollers_programming/lab4/spanish/#trabajando-en-simulacion","title":"Trabajando en simulaci\u00f3n","text":"<p>Se puede simular un encoder en wokwi utilizando el componente Rotatory Encoder. El diagrama en simulaci\u00f3n quedar\u00eda de la siguiente forma:</p> <p></p> <p>PREGUNTA: \u00bfQu\u00e9 diferencias hay entre el funcionamiento de este enc\u00f3der con el del motor de las pr\u00e1cticas?</p>"},{"location":"mqtt/","title":"MQTT","text":""},{"location":"mqtt/#mqtt","title":"MQTT","text":"<ul> <li> <p>Getting Started: \"A hands-on introduction to MQTT\".</p> <p>Here you will start working with MQTT.</p> </li> <li> <p>Exercise 1:: \"MQTT with ESP32 in wokwi\".</p> <p>In this exercise you will learn how to develop an IoT application based on MQTT that allows you to publish and subscribe to topics with an ESP32 in simulation from Wokwi.</p> </li> <li> <p>Exercise 2:: \"MQTT with ESP32 in the real world\".</p> <p>Example of MQTT application with a real ESP32.</p> </li> <li> <p>Lab Session:: \"MQTT with M5Core2\".</p> <p>MQTT Lab Exercise with the M5 Core 2 device.</p> </li> </ul>"},{"location":"mqtt/exercise1/","title":"Exercise 1: MQTT with ESP32 in wokwi","text":"<p>This section from the Industrial Informatics Course provides a practical guide to understanding and implementing MQTT with an ESP32 in simulation</p>"},{"location":"mqtt/exercise1/#contents","title":"Contents","text":"<ul> <li> <p>1. Connect to a network via WiFi</p> <ul> <li>How to connect the device to a network.</li> </ul> </li> <li> <p>2. Create a client and connect to a MQTT broker</p> <ul> <li>How to create an ESP32 client and connect it to a MQTT broker.</li> </ul> </li> <li> <p>3. Create a publisher</p> <ul> <li>How to publish messages to a topic with an ESP32 client.</li> </ul> </li> <li> <p>4. Create a subscriber</p> <ul> <li>How to subscribe to a topic to receive messages with an ESP32 client.</li> </ul> </li> <li> <p>5. Exercise: practical application</p> <ul> <li>A simple practical exercise to put practice the knowledge acquired in this part of the course.</li> </ul> </li> </ul> <p>This guide is designed to help learners set up and operate an MQTT broker, forming the foundation for efficient message exchange between IoT devices.</p>"},{"location":"mqtt/exercise1/part1_connect_wifi/","title":"1. Connect to a network via WiFi","text":"<p>In order to develop an IoT application using MQTT with an ESP32, the first thing we need to do is to connect the device to a network. Although this can be done in several ways, the most convenient way is to do it to a WiFi network. </p> <p>Let's do it in Wokwi!</p> <p>Warning</p> <p>As we are working in wokwi remotely, the ESP32 will have to connect to a wifi network accessible from the wokwi servers (i.e., you cannot connect the device to your WiFi network). Wokwi simulates a WiFi network with full internet access and provides a virtual WiFi access point called Wokwi-GUEST. It is an open access point - no password is required. For more info about network access in wokwi, check this link.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> wifi_connect.ino<pre><code>#include &lt;WiFi.h&gt; // (1)!\n\n#define WIFI_SSID \"Wokwi-GUEST\" // (2)!\n#define WIFI_PASSWORD \"\" // (3)!\n#define WIFI_CHANNEL 6 // (4)!\n\nvoid ConnectWiFi() // (5)!\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL); // (6)!\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED) // (7)!\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid setup(void) \n{\n  Serial.begin(115200);\n  ConnectWiFi(); // (8)!\n}\n\nvoid loop()\n{\n  delay(10); // (9)!\n}\n</code></pre> <ol> <li>The ESP32 WiFi library is based on the Arduino WiFi library and enables network connection (local and Internet) via WiFi.</li> <li>Here we define the name of the wifi network to which we want the device to connect. If you want to use the ESP32 in the real world, you need to enter the name of your local network</li> <li>Introduce the password of the network</li> <li>This is required in wokwi only. According to the documentation: We specify the WiFi channel number (6) when calling WiFi.begin(). This skips the WiFi scanning phase and saves about 4 seconds when connecting to the WiFi.</li> <li>This function is used to connect to the WiFi network (you can reuse it in your projects).</li> <li>This method initializes the WiFi library's network settings. If you don't want to use WIFI_CHANNEL (i,e., in real world project), you can delete the third argument of the function.    </li> <li>Wait until the device has connected to the network, when it's connected, it will display it through the serial port.</li> <li>The function <code>ConnectWiFi()</code> is called from the <code>setup()</code> so that the device connects to the network at the beginning of the program.</li> <li>This scripts doesn't do anything else, so there's nothing inside the <code>loop()</code>. Don't forget the <code>delay(10)</code> to speed up the simulation in wokwi (this is not needed in real world applications)</li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to connect an ESP32 to a WiFi network</p>"},{"location":"mqtt/exercise1/part2_client_connect/","title":"2. Create a client and connect to a MQTT broker","text":"<p>Let's extend the code from the previous entry and connect the ESP32 to a broker. </p> <p>Info</p> <p>The ESP32 is a simulated device in wokwi, so you won't be able to use your own broker (see 1. Install Mosquitto) unless you have allowed access to your network over the internet (this wasn't explained in thi course). Hence, let's use use a third party broker: the broker test.mosquitto.org. </p> <p>Public MQTT Broker</p> <p>Be aware that you're going to use a third party broker which is completely open. This implies that, first, you should not share relevant or sensitive information through that broker and use it only to test your MQTT application.</p> <p>Client and Topic names</p> <p>This broker is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_connect.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt; // (1)!\n#include &lt;PubSubClient.h&gt; // (2)!\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"test.mosquitto.org\"; // (3)!\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test\"; // (4)!\n\nWiFiClient espClient; // (5)!\nPubSubClient mqttClient(espClient); // (6)!\n\nvoid ConnectWiFi() // (7)!\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt() // (8)!\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT); \n}\n\nvoid ConnectMqtt() // (9)!\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\"try again in 5 seconds\");\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt() // (10)!\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt(); // (11)!\n}\n\nvoid loop()\n{\n  HandleMqtt(); // (12)!\n  delay(10);\n}\n</code></pre> <ol> <li>WiFiClient allows the creation of a client that can connect to to a specified internet IP address and port. In this case, you will use it to create a client connected to the test.mosquitto.org broker (server).</li> <li>PubSubClient allows a client for doing simple publish/subscribe messaging with a server that supports MQTT.</li> <li>You need to specify the broker address (test.mosquitto.org). If you want to use it with another broker, you need to specify the IP of the broker here (e.g., 192.168.0.12). You need to specify the broker port (by default, 1883 in MQTT).  NOTE THE * !!</li> <li>You need to specify the client name. Don't use a generic name, this name is the one that will be use the broker and other devices of the MQTT network. NOTE THE * !!</li> <li>Create the client. This name is not the client name in the network, but the name of the object in the script. I.e., you can choose the name freely as it won't be seen by anyone. </li> <li>Create the MQTT client.</li> <li>This functions is the same as the one in connect_wifi.</li> <li>This function initializes the client in the MQTT broker (you need to specify the IP address and port of the broker=server). I know there's only one line of code inside the function, it's been done on purpose. You'll see the reason in subscriber.</li> <li>This function connects the client to the broker. If the client isn't connected, it will try to connect every 5 seconds. If the client connects, it'l display it through the serial port.</li> <li>This function handles the connection to the broker. If the connection is lost, it calls the <code>ConnectMqtt()</code> function. If the client is connected, it uses the <code>mqtt.loop()</code> to check for new messages.</li> <li>The function <code>InitMqtt()</code> is called in the <code>setup()</code>.</li> <li>The funcion <code>HandleMqtt()</code> is called in the loop to keep the client connected and constantly check for new messages.</li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> <p>Cannot connect to broker</p> <p>It is possible that you've found problems when connecting to the broker <code>test.mosquitto.org</code>. Keep in mind that this server is public and is used by thousands of people simultaneously, so sometimes it doesn't work properly. Alternatively, you can use other free public brokers (e.g., the one used in the image above: <code>mqtt.eclipseprojects.io</code>).</p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to connect a MQTT client with an ESP32 and connect it to a broker</p>"},{"location":"mqtt/exercise1/part3_publisher/","title":"3. Create a publisher","text":"<p>Let's give some action to our MQTT application. This entry shows how you can create a publisher with an ESP32 in wokwi that can send messages to your PC. </p> <p>Client and Topic names</p> <p>You're going to use a public broker that is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_publisher.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_pub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload; // (1)!\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  // Wait for connection\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.print(\"Client connected\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid PublishMqtt(unsigned long data) // (2)!\n{\n  payload = \"\";\n  payload = String(data);\n  mqttClient.publish(\"/running_time\", (char *)payload.c_str());\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop()\n{\n  HandleMqtt();\n\n  PublishMqtt(millis()); // (3)!\n  Serial.println(millis()); \n\n  delay(1000);\n}\n</code></pre> <ol> <li>The client will publish messages to a topic using the method  <code>publish()</code> from the <code>PubSubClient.h</code> library. Checking the code of that method you will see it publishes <code>char</code> data. Remember the difference between <code>char</code> and <code>String</code>: In C++, the sequence of characters can be stored in two ways: either as a <code>std::string</code> (<code>String</code> in Arduino) object or <code>char array</code>. The latter is an array that contains single characters terminated by a null character, while the former creates an object that is used to represent strings in C++ and contain many methods to help in string manipulation. Since it's easier to manipulate <code>String</code>data than <code>char</code> data, we will use the <code>String</code> object <code>payload</code> to store the message that will be publish. This message, however, will need to be casted to a <code>char</code>before being published with <code>publish()</code> (explained later in the code). </li> <li>This function is used to publish <code>data</code> in a specific topic. It receives the <code>data</code> as a parameter (in this case <code>data</code> is an <code>unsigned long</code> variable, but it could have been something else, e.g., a <code>boolean</code>, or a <code>float</code>). The content of data need to be casted into <code>String</code>: here's when you use the <code>payload</code> variable. Then, the content of <code>payload</code> need to be casted into <code>char</code> according to the specifications of the method <code>publish()</code>. This is done with <code>(char *)payload.c_str()</code>.</li> <li>The function <code>PublishMqtt()</code> is called in the loop every 1s. The running time in milliseconds is given as a parameter to that function, meaning that will be the message to be published. </li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> <p>Info</p> <p>By checking the topic in MQTT Explorer you can see the time in milliseconds it takes for the ESP32 to publish the message and print over the serial port: 4 ms (it has to run the code inside <code>PublishMqtt()</code>, which also runs the method <code>publish()</code>).</p> </li> <li> <p>Subscribe to the topic in your terminal </p> <p>Run the following command in the terminal and you'll see that the ESP32 is communicating with your PC via MQTT as shwon in the image below </p><pre><code>mosquitto_sub -h mqtt.eclipseprojects.io -t /running_time\n</code></pre> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to publish messages to a MQTT topic with an ESP32.</p>"},{"location":"mqtt/exercise1/part4_subscriber/","title":"4. Create a subscriber","text":"<p>This entry shows how you can create a subscriber with an ESP32 in wokwi that can subscribe to topics. </p> <p>Client and Topic names</p> <p>You're going to use a public broker that is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_subscriber.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_sub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload;\nString content = \"\"; // (1)!\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n  SuscribeMqtt(); // (2)!\n  mqttClient.setCallback(OnMqttReceived); // (3)!\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n      SuscribeMqtt(); // (4)!\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid SuscribeMqtt() // (5)!\n{\n  mqttClient.subscribe(\"/testing_topic\");\n}\n\nvoid OnMqttReceived(char *topic, byte *payload, unsigned int length) // (6)!\n{\n  Serial.print(\"Received on \");\n  Serial.print(topic);\n  Serial.print(\": \");\n\n  content = \"\"; \n  for (size_t i = 0; i &lt; length; i++) // (7)!\n  {\n    content.concat((char)payload[i]);\n  }\n  Serial.print(content);\n  Serial.println();\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop() // (8)!\n{\n  HandleMqtt();\n  delay(10);\n}\n</code></pre> <ol> <li>As the message received in the topic will be a <code>char</code>, you'll use this variable to convert it to <code>String</code> for easier manipulation.</li> <li>Now, after setting the server, we need to call the function <code>SubscribeMqtt()</code>. This functions establishes the topics to which the client will be subscribed. This operation is a function for two reasons: <ol> <li>If the client is disconnected, it needs to subscribe to the topics again. So the function can be called multiple times in the code.</li> <li>If there is (or could be in the future) more than one topics to subscribe to, it can be easily addressed by simply modifying the code inside this function.</li> </ol> </li> <li>We need to set the function (callback) that will be called everytime a message is received. This function has been named <code>OnMqttReceived</code>.</li> <li><code>SubscribeMqtt()</code> is called again if the connection to the broker is lost.</li> <li><code>SubscribeMqtt()</code> defines the topics to which the client will subscribe. In this case, it will only subscribe to the topic <code>/testing_topic</code>, but there could be more than one inside the function. The client is subscribed to a topic using the method  <code>subscribe()</code> from the <code>PubSubClient.h</code> library. </li> <li>This function is a callback that will be called everytime a message is published in any of the topics that the client is subscribed to (similar to an interruption). Inside the callback, you get access to the <code>topic</code> where the message was published, the content of the message throught the variable <code>payload</code>, and the <code>length</code> of that message. </li> <li>The content of <code>payload</code> will be casted into <code>String</code>. In this case, <code>payload</code> is an array of bytes. These <code>bytes</code> need to be first casted into characters and then concatenated to form the final <code>String</code>. To do this, we first need to go through all the positions of the array (i.e., we use a <code>for</code> loop). This loop will go from the first element (<code>i=0</code>) to the last one (<code>i=length</code>). In every step of the loop, we first cast the element <code>i</code> of the array <code>payload</code> to <code>char</code>: <code>(char)payload[i]</code>. The data of this element should be concatenated to the string of <code>content</code> to form the final message. To do that we can use the method <code>concat()</code>. When the loop finishes, the <code>content</code> of the message is displayed through the serial port.</li> <li>This client works as a subscriber only. It means it won't do anything until a message is received. Hence, there's nothing inside the <code>loop()</code> (apart from the <code>HandleMqtt()</code> funcion that was explained in a previous entry).  </li> </ol> </li> <li> <p>If you have done it correctly, you should see that the ESP32 prints the content of the messages received in the topic <code>/testing_topic</code>. You can test it from the MQTT Explorer or the terminal.</p> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to subscribe to a MQTT topic with an ESP32.</p>"},{"location":"mqtt/exercise1/part5_exercise/","title":"5. Exercise: practical application","text":"<p>An exercise is proposed to communicate two ESP32s in an MQTT netword. One of them acts as publisher while the other as subscriber. The one that has the role of publisher has a button connected and, when the button is pressed (or released), it publishes in a topic that the button has been pressed. The other ESP32 will have a LED connected and will subscribe to the topic in which the ESP32 publisher publishes. Then, each time it receives a message in the topic, it changes the state of the LED.</p> <p>To test the application you can open two tabs in the browser and check that it works as follows:</p> <p></p> <p>Try to solve the problem before seeing the solution below.</p> Show publisher diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": -124.8,\n      \"left\": -187.16,\n      \"attrs\": {}\n    },\n    {\n      \"type\": \"wokwi-pushbutton\",\n      \"id\": \"btn1\",\n      \"top\": -3.4,\n      \"left\": -326.4,\n      \"attrs\": { \"color\": \"green\", \"bounce\": \"0\" }\n    }\n  ],\n  \"connections\": [\n    [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n    [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ],\n    [ \"btn1:1.r\", \"esp:14\", \"green\", [ \"v0\" ] ],\n    [ \"btn1:2.r\", \"esp:GND.1\", \"black\", [ \"h0\" ] ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> Show publisher code mqtt_publisher_button.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n# define BUTTON_PIN 14\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_pub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload; \n\nvolatile bool button_released = false;\n\n\nvoid IRAM_ATTR buttonReleased(){\n  button_released = true;\n}\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.print(\"Client connected\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid PublishMqtt(bool data) \n{\n  payload = \"\";\n  payload = String(data);\n  mqttClient.publish(\"/button_released\", (char *)payload.c_str());\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt((BUTTON_PIN)), buttonReleased, FALLING);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop()\n{\n  HandleMqtt();\n\n  if (button_released){\n    PublishMqtt(true);\n    Serial.println(\"Publishing button data\");\n    button_released = false;\n  }\n\n  delay(10);\n}\n</code></pre> Show subscriber diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juanma Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    { \"type\": \"board-esp32-devkit-c-v4\", \"id\": \"esp\", \"top\": -38.4, \"left\": -158.36, \"attrs\": {} },\n    {\n      \"type\": \"wokwi-led\",\n      \"id\": \"led1\",\n      \"top\": -42,\n      \"left\": -274.6,\n      \"attrs\": { \"color\": \"green\" }\n    },\n    {\n      \"type\": \"wokwi-resistor\",\n      \"id\": \"r1\",\n      \"top\": 41.8,\n      \"left\": -288.85,\n      \"rotate\": 270,\n      \"attrs\": { \"value\": \"1000\" }\n    }\n  ],\n  \"connections\": [\n    [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n    [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ],\n    [ \"led1:C\", \"r1:2\", \"black\", [ \"v0\" ] ],\n    [ \"r1:1\", \"esp:GND.1\", \"black\", [ \"v38.4\", \"h105.45\" ] ],\n    [ \"led1:A\", \"esp:26\", \"green\", [ \"v0\" ] ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> Show subscriber code mqtt_subscriber_LED.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define LED_PIN 26       \n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_sub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload;\nString content = \"\"; \n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n  SuscribeMqtt(); \n  mqttClient.setCallback(OnMqttReceived); \n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n      SuscribeMqtt(); \n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid SuscribeMqtt() \n{\n  mqttClient.subscribe(\"/button_released\");\n}\n\nvoid OnMqttReceived(char *topic, byte *payload, unsigned int length) \n{\n  Serial.print(\"Received on \");\n  Serial.print(topic);\n  Serial.print(\": \");\n\n  content = \"\"; \n  for (size_t i = 0; i &lt; length; i++) \n  {\n    content.concat((char)payload[i]);\n  }\n\n  Serial.print(content);\n  Serial.println();\n\n  digitalWrite(LED_PIN, !digitalRead(LED_PIN));\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  pinMode(LED_PIN, OUTPUT);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop() \n{\n  HandleMqtt();\n  delay(10);\n}\n</code></pre>"},{"location":"mqtt/exercise2/","title":"Exercise #2: MQTT with ESP32 in real world","text":"<p>TBD</p>"},{"location":"mqtt/getting_started/","title":"Getting Started: A hands-on introduction to MQTT","text":"<p>This section from the Industrial Informatics Course provides a practical guide to understanding and implementing MQTT (Message Queuing Telemetry Transport), a lightweight messaging protocol widely used in IoT (Internet of Things) applications.</p>"},{"location":"mqtt/getting_started/#contents","title":"Contents","text":"<ul> <li> <p>1. Install Mosquitto</p> <ul> <li>Step-by-step instructions for installing Mosquitto, an open-source MQTT broker, on your system.</li> </ul> </li> <li> <p>2. Testing Mosquitto from the terminal</p> <ul> <li>Guidance on testing the Mosquitto installation using terminal commands to verify its proper operation.</li> </ul> </li> <li> <p>3. Allow External Connections</p> <ul> <li>Steps to configure Mosquitto to accept external client connections, enabling communication over a network.</li> </ul> </li> </ul> <p>This guide is designed to help learners set up and operate an MQTT broker, forming the foundation for efficient message exchange between IoT devices.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/","title":"1. Install Mosquitto","text":""},{"location":"mqtt/getting_started/part1_install_mosquitto/#introduction","title":"Introduction","text":"<p>Eclipse Mosquitto is an Open Source Broker from the Eclipse Foundation distributed under EPL/EDL license that implements MQTT protocol. It is lightweight and is suitable for use on all devices from low power single board computers to full servers. It is programmed in C and is compatible with most OS. The code can be found in this repo.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#installation","title":"Installation","text":"<p>To install Mosquitto, you can follow the next steps.</p> <p>Info</p> <p>\"The steps below outline the Mosquitto installation process for Windows. If you are using Ubuntu, the installation process is much easier. You can find the steps for Ubuntu installation here. </p> <ol> <li>Download the installer from the official website. Check the corresponding type of your processor architecture (most probably 64-bit). Once you have the <code>.exe</code>, execute it to start the installation process.</li> <li>During the installation, install all the components.</li> </ol> <p></p> <ol> <li>When the installer asks you for the Destination Folder, leave the default one (most probably: <code>C:\\Program Files\\mosquitto</code>).</li> </ol> <p></p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#start-mosquitto","title":"Start Mosquitto","text":"<p>Now, you can start mosquitto through windows services. You can open the services by clicking the Win button and typing <code>Services</code>.  Here you can check the multiple ways to open windows services.</p> <p></p> <p>Once you have find the mosquito broker service, you can click on Start the service to start and enable the port where the mosquito will start listening for requests.</p> <p></p> <p>Info</p> <p>It may happen that when you open the windows services, mosquitto is already running.</p> <p>You can check in the terminal (Win <code>cmd</code>) if the service is active and the port enabled with the following command.</p> <pre><code>netstat -an\n</code></pre> <p></p> <p>Then you will see a list of enabling ports. Port 1883 is the one used by mosquitto for communication.</p> <p></p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#firewall","title":"Firewall","text":"<p>As mosquitto requires external communication, it is necessary to enable the windows firewall for incoming and outgoing requests on port 1883 (this way, the firewall does not block the mosquitto service).</p> <p>You need to go to <code>Control panel &gt; Windows defender firewall</code>. Then, go yo <code>advanced setting</code>.</p> <p></p> <p>It will open the Advanced Configuration of Firewall window where you have to look for inbound rules and click on new rule.</p> <ol> <li>The first step is to select the type of rule. In this case it is a port, so select it and click on next.</li> <li>Then, you select the rule for <code>tcp</code> and we write the corresponding port: <code>1883</code>. Click on <code>next</code> and allow all the connections.</li> <li>Apply the rule to all the network profiles and place a name to identify it. Click on finish and the rule will be created.</li> </ol> <p>Now you can create the outbound rule. Click on outbound rule and do the same steps you did before.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#path-environment-variable","title":"Path Environment Variable","text":"<p>Once you have Mosquitto running as a service and the firewall is correctly configured, you need to configure the environment variable.</p> <p>Info</p> <p>This is not strictly required but highly recommended. If you don't do this, you can only run Mosquitto commands in the terminal from the root installation folder <code>C:\\Program Files\\mosquitto</code>. If you add this folder to the Path, then you'll be able to run those commands from any location on your system. </p> <p>You need to acced the <code>environment variables</code> and search for the variable path to place the route <code>Control Panel &gt; System and security &gt; System</code>. </p> <p></p> <p>Then, open the advanced system configuration and click on <code>environment variables</code>.</p> <p></p> <p>Include the path where mosquitto was installed (remember step 3 of installation<code>C:\\Program Files\\mosquitto</code>). </p> <p></p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/","title":"2. Testing Mosquitto from the terminal","text":""},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#testing","title":"Testing","text":"<p>If you have already completed Part 1, now you can test mosquitto broker in your local machine. Open one terminal (Win + <code>cmd</code>) and go to the route where mosquitto was installed</p> <pre><code>cd C:\\Program Files\\mosquitto\n</code></pre> <p>Info</p> <p>If you have already configured the variable path in Part 1, the previous step should not be necessary.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#creating-a-subscriber","title":"Creating a subscriber","text":"<p>This terminal will act as a subscriber and will receive the messages published in the topic <code>/test</code>. To do so, run the following command</p> <pre><code>mosquitto_sub -h localhost -t /test\n</code></pre> <ol> <li> <p><code>mosquitto_sub</code> </p> <ul> <li>This is the Mosquitto client tool used to subscribe to an MQTT topic.</li> <li>It listens for messages published to specific topics.</li> </ul> </li> <li> <p><code>-h localhost</code> </p> <ul> <li><code>-h</code> specifies the host or broker address to connect to.</li> <li><code>localhost</code> means the broker is running on the same machine where the command is being executed. If the broker is on a remote server, you'd need to replace    <code>localhost</code> with the server's IP address or domain name.</li> </ul> </li> <li> <p><code>-t /test</code> </p> <ul> <li><code>-t</code> specifies the topic to subscribe to.</li> <li><code>/test</code> is the topic name in this example. Topics are hierarchical strings used by MQTT brokers to route messages. In this case, the client will subscribe to the <code>/test</code> topic and receive any messages published to it.</li> </ul> </li> </ol>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#explanation","title":"Explanation:","text":"<p>The command subscribes to the MQTT topic <code>/test</code> on a broker running locally (at <code>localhost</code>). Messages sent to the <code>/test</code> topic by other MQTT clients or publishers will be received and displayed by this subscriber.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#creating-a-publisher","title":"Creating a publisher","text":"<p>Without closing that terminal, open another one (Win + <code>cmd</code>). This second terminal will act as a publisher that will publish the message This is a testing message: Hello, MQTT! in the topic <code>/test</code>. This message will be received by the subscriber and will display it in the terminal</p> <pre><code>mosquitto_pub -h localhost -t /test -m \"This is a testing message: Hello, MQTT!\"\n</code></pre> <ol> <li> <p><code>mosquitto_pub</code> </p> <ul> <li>This is the Mosquitto client tool used to publish messages to an MQTT topic.</li> <li>It sends messages to the specified topic on the broker.</li> </ul> </li> <li> <p><code>-h localhost</code> </p> <ul> <li><code>-h</code> specifies the host or broker address to connect to.</li> <li><code>localhost</code> means the broker is running on the same machine where the command is being executed. If the broker is on a remote server, you'd replace <code>localhost</code> with the server's IP address or domain name.</li> </ul> </li> <li> <p><code>-t test</code> </p> <ul> <li><code>-t</code> specifies the topic to which the message will be published.</li> <li><code>test</code> is the topic name in this example. Other MQTT clients subscribed to this topic will receive the message.</li> </ul> </li> <li> <p><code>-m \"This is a testing message: Hello, MQTT!\"</code> </p> <ul> <li><code>-m</code> specifies the message to publish.</li> <li><code>\"This is a testing message: Hello, MQTT!\"</code> is the message content being sent to the <code>test</code> topic. Clients subscribed to the topic will see this exact message.</li> </ul> </li> </ol>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#explanation_1","title":"Explanation:","text":"<p>The command publishes the message <code>\"This is a testing message: Hello, MQTT!\"</code> to the MQTT topic <code>test</code> on a broker running locally (at <code>localhost</code>). Any MQTT clients subscribed to the <code>test</code> topic will receive this message.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#expected-result","title":"Expected result","text":"<p>If you have correctly done all the steps, you should have seen the following:</p> <p></p> <p>Note</p> <p>The subscriber will keep running indefinitely, waiting for messages. On the other hand, the publisher runs only once to send a single message. If you want to send more messages, you will need to re-run the entire command each time</p>"},{"location":"mqtt/getting_started/part3_external_connections/","title":"3. Allow External Connections","text":"<p>Connection from an external network</p> <p>This section allows you to connect external devices within a local network to the broker that you have created in Part1. When this section talks about IP address, it refers to the private IP address (i.e., the one assigned by the router that creates the network and that is only accessible by the devices that are on the network). If you want to work with devices outside the network, you need to work with the public IP address (which is unique and visible to everyone). If you would like to configure a broker to allow connections through the internet from external networks, you would have to configure port forwarding on the router (similarly to what you did in Part1 with the windows firewall). This could pose several security risks and would require taking precautions such as using TLS/SSL Encryption or a MQTT Proxy. This is out of the scope of this course, so it will not be explained here.</p>"},{"location":"mqtt/getting_started/part3_external_connections/#1-allow-external-connections","title":"1. Allow External Connections","text":"<p>By default, Mosquitto listens only on <code>localhost</code>. To allow external connections:</p> <ol> <li> <p>Open the Mosquitto configuration file (<code>mosquitto.conf</code>). The file is typically located in:</p> <ul> <li>Linux: <code>/etc/mosquitto/mosquitto.conf</code></li> <li>Windows: Wherever you installed Mosquitto, e.g., <code>C:\\Program Files\\mosquitto\\mosquitto.conf</code></li> </ul> </li> <li> <p>Add or edit the following line to bind Mosquitto to all network interfaces:     </p><pre><code>listener 1883\n</code></pre> <p></p> <ul> <li><code>1883</code> is the default MQTT port. If you want a custom port, specify it here.</li> <li>To restrict it to a specific IP, replace <code>listener 1883</code> with <code>listener 1883 &lt;IP Address&gt;</code>.</li> </ul> </li> <li> <p>Restart the Mosquitto service for changes to take effect:</p> <ul> <li>Linux:     <pre><code>sudo systemctl restart mosquitto\n</code></pre></li> <li>Windows: Restart Mosquitto from the Windows Services </li> </ul> </li> </ol> <p>Warning</p> <p>To edit a file inside <code>C:\\Program Files\\mosquitto\\</code>, you'll need administrator rights. To change the <code>mosquitto.conf</code>file, you can open it with VSCode (or any other text editor, e.g., notepad or gedit) if you open it as administrator.</p> <p></p>"},{"location":"mqtt/getting_started/part3_external_connections/#2-enable-username-and-password-authentication","title":"2. Enable Username and Password Authentication","text":"<ol> <li> <p>Create a password file:  </p> <ul> <li> <p>Linux:</p> <p>Use the <code>mosquitto_passwd</code> utility to generate the password file: </p><pre><code>mosquitto_passwd -c /etc/mosquitto/password &lt;username&gt;\n</code></pre> Replace <code>&lt;username&gt;</code> with your desired username. You will be prompted to enter a password. <p>Example: </p><pre><code>mosquitto_passwd -c /etc/mosquitto/password user1\n</code></pre> <code>-c</code> creates a new password file. If you want to add more users later, use: <pre><code>mosquitto_passwd /etc/mosquitto/password &lt;new-username&gt;\n</code></pre> </li> <li> <p>Windows:</p> <p>Use the <code>mosquitto_passwd</code> utility to generate the password file: </p><pre><code>mosquitto_passwd -c C:\\Program Files\\mosquitto\\password &lt;username&gt;\n</code></pre> Replace <code>&lt;username&gt;</code> with your desired username. You will be prompted to enter a password.  <p>Warning</p> <p>To edit a file inside <code>C:\\Program Files\\mosquitto\\</code>, you'll need administrator rights. If you run the previous command, you'll write in the <code>C:\\Program Files\\mosquitto\\password</code> file. To do so, you can open the terminal as administrator.</p> <p></p> <p>Example: </p><pre><code>mosquitto_passwd -c C:\\Program Files\\mosquitto\\password user1\n</code></pre> <p></p> <p><code>-c</code> creates a new password file. If you want to add more users later, use:</p> <pre><code>mosquitto_passwd C:\\Program Files\\mosquitto\\password &lt;new-username&gt;\n</code></pre> </li> </ul> </li> <li> <p>Update the configuration file to use the password file:</p> <ul> <li> <p>Linux:</p> <p>Open <code>mosquitto.conf</code> and add or edit the following lines: </p><pre><code>allow_anonymous false\npassword_file /etc/mosquitto/passwords\n</code></pre> </li> <li> <p>Windows:</p> <p>Open <code>mosquitto.conf</code> and add or edit the following lines: </p><pre><code>allow_anonymous false\npassword_file C:\\Program Files\\mosquitto\\password\n</code></pre> </li> </ul> <p></p> </li> <li> <p>Restart the Mosquitto service:</p> <ul> <li>Linux:     <pre><code>sudo systemctl restart mosquitto\n</code></pre></li> <li>Windows: Restart as mentioned earlier.</li> </ul> </li> </ol> <p>Warning</p> <p>If you receive this error when you try to restart the Mosquitto service</p> <p></p> <p>you must change the permissions of the <code>password</code> file. </p> <ul> <li>Find the password file in <code>C:/Program Files/mosquitto</code>, right click &gt; properties and go to the security tab. </li> </ul> <p>Check if the SYSTEM group has permissions to modify the file. If it does not, you will have to give them as follows. </p> <ul> <li>Click on Edit and then on Add.  </li> </ul> <p></p> <ul> <li>Add the group SYSTEM and give it permissions to modify the file and click on apply (this is very important).</li> </ul> <p></p> <p>The result should look like this</p> <p></p>"},{"location":"mqtt/getting_started/part3_external_connections/#3-firewall-rules","title":"3. Firewall Rules","text":"<p>If Mosquitto is running on a remote machine, make sure the firewall allows connections to the MQTT port (1883 by default).</p> <ul> <li> <p>Linux (using UFW):     </p><pre><code>sudo ufw allow 1883\n</code></pre> </li> <li> <p>Windows: Open \"Windows Defender Firewall,\" and allow inbound traffic for port 1883.</p> </li> </ul> <p>Note</p> <p>This was already done in Part 1</p>"},{"location":"mqtt/getting_started/part3_external_connections/#4-testing-external-access","title":"4. Testing External Access","text":""},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-a-generic-mqtt-client-mqtt-explorer","title":"Testing from a generic MQTT Client (MQTT Explorer)","text":"<p>You can test the connection from a generic MQTT Client like MQTT Explorer.</p> <ol> <li>Install MQTT Explorer.</li> <li> <p>Check the IP of the broker. Open a terminal and run</p> <ul> <li> <p>Linux </p><pre><code>ipconfig\n</code></pre> </li> <li> <p>Windows:      </p><pre><code>ifconfig\n</code></pre> </li> </ul> <p></p> <p>You need to annotate the IPv4 address. In my case: <code>192.168.0.12</code></p> </li> <li> <p>Launch MQTT Explorer and fill the IP, user and password</p> <p></p> </li> <li> <p>Publish in a topic from MQTT Explorer</p> <p></p> </li> </ol>"},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-another-pc","title":"Testing from another PC","text":"<p>You can test the connection from another PC in the network that has installed mosquitto too:</p> <ol> <li> <p>Subscribe from the broker device:     </p><pre><code>mosquitto_sub -h &lt;server-ip&gt; -t test -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> <li> <p>Publish from an external device:     </p><pre><code>mosquitto_pub -h &lt;server-ip&gt; -t test -m \"This is a message from an external device: Hello, MQTT!\" -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> </ol> <p>Replace <code>&lt;server-ip&gt;</code> with the server's IP address, <code>&lt;username&gt;</code> with your chosen username, and <code>&lt;password&gt;</code> with the associated password.</p>"},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-an-smartphone","title":"Testing from an Smartphone","text":"<p>You can test the connection from a Smartphone in the network that has installed mosquitto too:</p> <ol> <li>Install MyMQTT</li> <li> <p>Connect to the broker</p> <p></p> </li> <li> <p>Subscribe to topic <code>/test</code> and go to the Dashboard</p> <p></p> </li> <li> <p>Publish a message in <code>/test</code>from another device in the newtork (e.g., from a terminal in your PC)      </p><pre><code>mosquitto_pub -h &lt;server-ip&gt; -t test -m \"This is a message from an external device: Hello, MQTT!\" -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> <li> <p>The message should be visible in the MyMQTT Dashboard</p> <p></p> </li> </ol>"},{"location":"mqtt/getting_started/part3_external_connections/#summary-of-key-configuration-file-changes","title":"Summary of Key Configuration File Changes","text":"<pre><code>listener 1883\nallow_anonymous false\npassword_file /etc/mosquitto/passwords.txt\n</code></pre> <p>After completing these steps, Mosquitto will accept external connections (i.e., from external devices, but in the local network) on port 1883, and only users with valid credentials can publish or subscribe.</p> <p>CONGRATULATIONS!</p> <p>You have created your first MQTT local network and are able to communicate devices in the network using this protocol and to monitor the traffic of the network</p>"},{"location":"mqtt/lab1/","title":"Lab Session: MQTT with M5Core2","text":"<p>TBD</p>"},{"location":"real-time_embedded_systems/","title":"Real-Time","text":""},{"location":"real-time_embedded_systems/#real-time-for-embedded-systems","title":"Real-Time for Embedded Systems","text":"<ul> <li> <p>External data acquisition.</p> </li> <li> <p>Event-driven multi-tasking.</p> </li> <li> <p>Lab Session 6-I: \"RT multi-tasking without OS\".</p> </li> <li> <p>Intro to RTOS: \"Multitasking with FreeRTOS\".</p> </li> <li> <p>Lab Session 6-II: \"Multi-tasking with FreeRTOS\".</p> </li> </ul>"},{"location":"real-time_embedded_systems/event-driven/","title":"Event-driven multi-tasking","text":""},{"location":"real-time_embedded_systems/event-driven/#event-driven-multi-tasking","title":"Event-driven multi-tasking","text":""},{"location":"real-time_embedded_systems/event-driven/#example-exercise","title":"Example exercise","text":"<p>A button and an LED are connected to an ESP32, create a script that does the following:</p> <ul> <li>If the button is pressed for less than 1s, the LED changes state.</li> <li>If it is pressed for more than 1s, the LED blinks (500ms ON, 500ms OFF)</li> <li>If the button is pressed again, it turns off and deactivates the blinking (regardless of the state it is in).</li> </ul>"},{"location":"real-time_embedded_systems/event-driven/#exercise-6-fsm-hardware-solution","title":"Exercise 6: FSM hardware solution","text":"<p>For this solution we need to use an extra cable and GPIO pin for the button.</p> <p></p> <p></p> <p> \u2191 b:  </p><pre><code>activate timer_t\nstate = 1\n</code></pre> <p> timer_t:  </p><pre><code>long_press = true\n</code></pre> <p> \u2193 b:  </p><pre><code>deactivate timer_t\nif (long_press)\n    state = 3\n    activate timer_blink\n    long_press = false\nelse\n    state = 2\n    LED ON\n</code></pre> <p> timer_blink: </p> <pre><code>LED = !LED\n</code></pre> <p> \u2193 b: </p> <pre><code>LED OFF\nstate = 0\ndeactivate timer_blink\n</code></pre> <p>Download the solution here</p>"},{"location":"real-time_embedded_systems/event-driven/#exercise-7-fsm-method-1","title":"Exercise 7: FSM method 1","text":"<p>\u00e7</p> <p> \u2191 \u2193 b:  </p><pre><code>if (state == 0 &amp;&amp; b)            // before it was green\n    activate timer_t\n    state = 1\nelse if (state == 1 &amp;&amp; !b)      // before it was magenta\n    deactivate timer_t\n    if (long_press)\n        state = 3\n        activate timer_blink\n        long_press = false\n    else\n        state = 2\n        LED ON\nelse                            // before it was light blue\n    LED OFF\n    state = 0\n    deactivate timer_blink\n</code></pre> <p> timer_t:  </p><pre><code>long_press = true\n</code></pre> <p> timer_blink: </p> <pre><code>LED = !LED\n</code></pre> <p>Download the solution here</p>"},{"location":"real-time_embedded_systems/event-driven/#exercise-7-fsm-method-2","title":"Exercise 7: FSM method 2","text":"<p>The FSM design is the same as in exercise 7, but the software implementation is different: in this case there is a a prior FSM state evaluation.</p> <p>Download the solution here</p>"},{"location":"real-time_embedded_systems/external_data/","title":"External data acquisition","text":""},{"location":"real-time_embedded_systems/external_data/#external-data-acquisition","title":"External data acquisition","text":""},{"location":"real-time_embedded_systems/external_data/#polling","title":"Polling","text":""},{"location":"real-time_embedded_systems/external_data/#exercise-1-example-of-polling-programming","title":"Exercise 1: Example of polling programming","text":"<p>Based on the following diagram in which we have a linear potentiometer connected to an ESP32, create a script that publishes the data read from the potentiometer through the serial port with a frequency of 50Hz.</p> <p></p> <p>Download the solution</p>"},{"location":"real-time_embedded_systems/external_data/#exercise-2-problem-1-data-loss","title":"Exercise 2: Problem 1: Data loss","text":"<p>Include a push button and an LED, and modify the script so that each time the button is pressed, the state of the LED changes.</p> <p></p> <p>Download the solution</p>"},{"location":"real-time_embedded_systems/external_data/#exercise-3-example-of-interrupt-driven-programming","title":"Exercise 3: Example of interrupt-driven programming","text":"<p>Solution to Problem 1: Hardware interrupts  Modify the script so that each time the button is pressed, an interrupt is generated, preventing data loss.</p> <p>Download the solution</p>"},{"location":"real-time_embedded_systems/external_data/#exercise-4-problem-2-loss-of-timing-requirements","title":"Exercise 4:  Problem 2: Loss of timing requirements","text":"<p>Change the button task so that each time it is pressed, an interrupt is generated and the LED blinks 5 times with a period of half a second.</p> <p>Download the solution</p>"},{"location":"real-time_embedded_systems/external_data/#exercise-5-example-of-timer","title":"Exercise 5: Example of timer","text":"<p>Solution to Problem 2: Timer interrupts  Use a timer to make the LED blink with a half-second period and avoid loss of timing requirements.</p> <p>Download the solution</p>"},{"location":"real-time_embedded_systems/freeRTOS/","title":"Introduction to RTOS with embedded systems","text":""},{"location":"real-time_embedded_systems/freeRTOS/#introduction-to-rtos-with-embedded-systems","title":"Introduction to RTOS with embedded systems","text":""},{"location":"real-time_embedded_systems/freeRTOS/#freertos-instructions","title":"FreeRTOS Instructions","text":""},{"location":"real-time_embedded_systems/freeRTOS/#task-definition","title":"Task definition","text":"<pre><code>TaskHandle_t handle_task_name; \n</code></pre> <ul> <li><code>TaskHandle_t</code> is a typedef (alias) for a pointer type used by FreeRTOS to reference a task. It\u2019s essentially a handle that uniquely identifies a task within the RTOS scheduler.</li> <li><code>handle_task_name</code> is the variable name you\u2019re declaring. It will store the handle of a task after you create it.</li> <li>You usually declare the handle as a global variable</li> </ul> <pre><code>BaseType_t xTaskCreatePinnedToCore(\n    TaskFunction_t task_function,\n    const char * const task_description,\n    const uint32_t memory_in_words,  \n    void *parameters,\n    UBaseType_t task_priority,\n    TaskHandle_t *handle_task_name,\n    const BaseType_t core_ID     \n);\n</code></pre> <ul> <li><code>task_function</code>: The task function (<code>void task_function(void *parameters)</code>). The entry point for the task. It usually contains an infinite loop (<code>while(1)</code>).</li> <li><code>task_description</code>: Descriptive task name (for debugging). E.g., <code>\"Task 1\"</code>.</li> <li><code>memory_in_words</code>: Stack size in words (on ESP32 - 32-bit words, 1 word = 4 bytes). If you think in bytes, divide by 4. Example: 4096 bytes \u2192 4096 / 4 = 1024 words. It depends on what the task does (printf, floating point, deep call chains, libraries, etc.). If the memory is set too high, you'll waste RAM. If the memory is set two low you'll find an error like <code>***ERROR*** A stack overflow in task task_description has been detected.</code></li> <li><code>parameters</code>: Pointer passed to the task (or <code>NULL</code>). We'll always use <code>NULL</code> in the course.</li> <li><code>task_priority</code>: Task priority (higher number = higher priority). Guidelines: Keep typical app tasks around 1\u20135. Avoid competing with critical system tasks (Wi\u2011Fi/BLE) unless necessary. Only use very high priority for time-critical loops (e.g., your WNN control loop), and keep them efficient.  Pitfall: A high-priority task that doesn\u2019t block can starve others. Ensure it yields via vTaskDelay, queues, or event groups. We'll only use priorities 0 or 1.</li> <li><code>handle_task_name</code>: Receives the created task\u2019s handle. Use it to later suspend, resume, delete, change affinity (IDF APIs), or query stack.</li> <li><code>core_ID</code>: The CPU core the task is pinned to. On ESP32 0 or 1 to select the core. Arduino-ESP32 often runs the loopTask and Wi\u2011Fi on core 1; pinning your real-time/control task to core 0 can improve determinism.</li> </ul>"},{"location":"real-time_embedded_systems/freeRTOS/#minimal-example","title":"Minimal example","text":"<pre><code>TaskHandle_t HandleTaskName; \n\nvoid setup(){\n    xTaskCreatePinnedToCore(\n        taskFunction,           // Function name that implements the task\n        \"task description\",     // Task description\n        2048/4,                 // Memory (in bytes) assigned to this task (don't set too high)\n        NULL,                   // Task input parameter (none)\n        0,                      // Task priority 0\n        &amp;HandleTaskName,        // Handle of the task\n        0                       // Core where task 1 will run (this one in core 0)\n    );\n}\n\nvoid loop(){\n    // empty\n}\n\nvoid taskFunction(void *parameters)\n{\n    // Local constants/variables for this task (can share names across tasks without interfering)\n\n    // some code...\n\n    while (1) // infinite loop\n    {\n        // some code...\n    }\n}\n</code></pre>"},{"location":"real-time_embedded_systems/freeRTOS/#periodic-tasks","title":"Periodic tasks","text":"<pre><code>TickType_t xLastWakeTime;\n</code></pre> <ul> <li><code>TickType_t</code> is the unsigned integer type FreeRTOS uses for tick counts (system time in ticks). On ESP32 and most 32-bit ports it\u2019s 32\u2011bit. Each tick is a fixed time quantum defined by the RTOS tick rate.</li> <li><code>xLastWakeTime</code> is a variable that stores the reference tick for your task\u2019s last wake-up. You initialize it once before your periodic loop and then pass it by reference to <code>vTaskDelayUntil()</code> so FreeRTOS can wake the task at precise intervals (reduces jitter and drift vs. <code>vTaskDelay()</code>).</li> </ul> <pre><code>const TickType_t xPeriod = period_in_ms / portTICK_PERIOD_MS\n</code></pre> <ul> <li><code>portTICK_PERIOD_MS</code> is A constant that equals the duration of one tick in milliseconds. It is derived from <code>configTICK_RATE_HZ</code>: <code>portTICK_PERIOD_MS = 1000 / configTICK_RATE_HZ</code>. E.g., if <code>configTICK_RATE_HZ = 1000</code>, then <code>portTICK_PERIOD_MS = 1 ms</code> (1 tick = 1 ms). If <code>configTICK_RATE_HZ = 100</code>, then <code>portTICK_PERIOD_MS = 10 ms</code> (1 tick = 10 ms). By default, 1 tick = 1ms.</li> <li><code>xPeriod</code> is the period in ticks that you want the task to run at, computed from a desired period in milliseconds.</li> <li><code>period_in_ms</code> is the period in ms (here you can write the period of the task in ms).</li> <li>In practice, you can use the macro <code>pdMS_TO_TICKS(period_in_ms)</code> (preferred), which handles rounding and avoids integer mistakes:</li> </ul> <pre><code>const TickType_t xPeriod = pdMS_TO_TICKS(period_in_ms);\n</code></pre> <pre><code>vTaskDelayUntil(&amp;xLastWakeTime, xPeriod);\n</code></pre> <ul> <li><code>vTaskDelayUntil(&amp;xLastWakeTime, xPeriod)</code> is is a FreeRTOS API call used inside a task\u2019s loop to make it run at a fixed, periodic rate with minimal drift. It puts the current task to sleep until the next absolute wake-up time based on <code>xLastWakeTime</code> and <code>xPeriod</code>. Unlike <code>vTaskDelay()</code> (which sleeps relative to \u201cnow\u201d), <code>vTaskDelayUntil()</code> targets exact tick instants <code>(t0, t0 + T, t0 + 2T, \u2026)</code>, keeping a stable cadence even if individual iterations vary slightly in execution time.</li> </ul>"},{"location":"real-time_embedded_systems/freeRTOS/#minimal-example_1","title":"Minimal example","text":"<pre><code>TaskHandle_t HandleTaskName; \n\nvoid setup(){\n    xTaskCreatePinnedToCore(\n        taskFunction,           // Function name that implements the task\n        \"task description\",     // Task description\n        2048/4,                 // Memory (in bytes) assigned to this task (don't set too high)\n        NULL,                   // Task input parameter (none)\n        0,                      // Task priority 0\n        &amp;HandleTaskName,        // Handle of the task\n        0                       // Core where task 1 will run (this one in core 0)\n    );\n}\n\nvoid loop(){\n    // empty\n}\n\nvoid taskFunction(void *parameters)\n{\n    // Local constants/variables for this task (can share names across tasks without interfering)\n\n    const TickType_t xPeriod = pdMS_TO_TICKS(10);  // 10 ms period\n    TickType_t xLastWakeTime = xTaskGetTickCount();  // initialize once\n\n    // some code...\n\n    while (1) // infinite loop\n    {\n        // some code...\n\n        // Sleep until the next absolute release time (no drift)\n        vTaskDelayUntil(&amp;xLastWakeTime, xPeriod);\n    }\n}\n</code></pre>"},{"location":"real-time_embedded_systems/freeRTOS/#exercises","title":"Exercises","text":""},{"location":"real-time_embedded_systems/freeRTOS/#exercise-8-multicore-app-reading-from-two-analog-sensors","title":"Exercise 8: Multicore app reading from two analog sensors","text":"<p>Read from two analog sensors using both cores of the ESP32 (one sensor per core). One sensor is read at 1Hz, and the other at 2Hz.</p> <p></p> <p>Download the solution here</p>"},{"location":"real-time_embedded_systems/freeRTOS/#exercise-9-simple-multicore-app-with-two-buttons-and-two-leds","title":"Exercise 9: Simple multicore app with two buttons and two LEDs","text":"<p>Use one core to handle the red button and red LED, and the other core to handle the green button and green LED.  One the button is pressed, the LED changes its state.</p> <p></p> <p>Download the solution here</p>"},{"location":"real-time_embedded_systems/freeRTOS/#exercise-10-multicore-app-with-two-buttons-and-two-leds-and-periodic-tasks","title":"Exercise 10: Multicore app with two buttons and two LEDs, and periodic tasks","text":"<p>With the same diagram as in exercise 9, when the red button is pressed, the red LED blinks at 3Hz. When the green button is pressed, the green LED blinks at 2Hz. When a button is pressed again, its corresponding LED turns off.</p> <p>Download the solution here</p>"},{"location":"real-time_embedded_systems/lab6_1/","title":"Lab Session 6-I: Small-scale RT multitasking","text":""},{"location":"real-time_embedded_systems/lab6_1/#lab-session-6-i-small-scale-rt-multitasking","title":"Lab Session 6-I: Small-scale RT multitasking","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"real-time_embedded_systems/lab6_1/#1-working-with-real-hardware","title":"1. Working with real hardware","text":""},{"location":"real-time_embedded_systems/lab6_1/#part-1-buttons-interaction","title":"Part 1 - Buttons interaction","text":"<p>The M5Core2 device has 3 touch buttons defined as <code>M5.BtnA</code>, <code>M5.BtnB</code>, and <code>M5.BtnC</code>.</p> <ul> <li>Compile and test the example program <code>button_example.ino</code>.</li> <li>At this link you can find the documentation about the functions that can be performed with the buttons.</li> </ul> <p>Danger</p> <p>The documentation in the link before is for the new library <code>M5Unified.h</code>, which is very new and not very well tested.  Some of the functions in that documentation where not included in the old <code>M5Core2.h</code> library. Focus only on the functions used in <code>button_example.ino</code></p> <p>Question</p> <ul> <li>How do the buttons behave?</li> <li>What do the <code>wasReleased</code> and <code>pressedFor</code> functions do?</li> </ul>"},{"location":"real-time_embedded_systems/lab6_1/#part-2-secret-code","title":"Part 2 - Secret code","text":"<p>The program will have 4 states:</p> <ul> <li>State 0: No button has been pressed.</li> <li>State 1: The first button has been pressed correctly.</li> <li>State 2: The second button has been pressed correctly.</li> <li>State 3: The third button has been pressed correctly.</li> </ul> <p>The buttons must be pressed in the sequence A, B, C.</p> <ul> <li>If the correct button is pressed, the program moves to the next state.</li> <li>If an incorrect button is pressed, it returns to State 0.</li> </ul> <p>Note</p> <p>Each time the state changes, a message should be printed on the screen. For example: - If the program is in State 1: </p><pre><code>   M5.Lcd.println(\"First button correct\");\n</code></pre> - If the program is in State 3: <pre><code>M5.Lcd.println(\"CODE CORRECT!\");\n</code></pre>"},{"location":"real-time_embedded_systems/lab6_1/#2-working-in-simulation","title":"2. Working in simulation","text":"<p>You can do a similar exercise in sumation. </p>"},{"location":"real-time_embedded_systems/lab6_1/spanish/","title":"Sesi\u00f3n de Laboratorio 6-I: Multitarea en sistemas de tiempo real de peque\u00f1a escala","text":""},{"location":"real-time_embedded_systems/lab6_1/spanish/#sesion-de-laboratorio-6-i-multitarea-en-sistemas-de-tiempo-real-de-pequena-escala","title":"Sesi\u00f3n de Laboratorio 6-I: Multitarea en sistemas de tiempo real de peque\u00f1a escala","text":"<p>Tiempo estimado: 1,5 h (1 sesi\u00f3n)</p>"},{"location":"real-time_embedded_systems/lab6_1/spanish/#1-trabajando-con-hardware-real","title":"1. Trabajando con hardware real","text":""},{"location":"real-time_embedded_systems/lab6_1/spanish/#parte-1-interaccion-con-botones","title":"Parte 1 - Interacci\u00f3n con botones","text":"<p>El dispositivo M5Core2 tiene 3 botones t\u00e1ctiles definidos como <code>M5.BtnA</code>, <code>M5.BtnB</code> y <code>M5.BtnC</code>.</p> <ul> <li>Compila y prueba el programa de ejemplo <code>button_example.ino</code>.</li> <li>En este enlace puedes encontrar la documentaci\u00f3n sobre las funciones que se pueden realizar con los botones.</li> </ul> <p>Importante: La documentaci\u00f3n del enlace anterior corresponde a la nueva librer\u00eda <code>M5Unified.h</code>, que es muy reciente y no est\u00e1 demasiado probada. Algunas funciones de esa documentaci\u00f3n no est\u00e1n incluidas en la librer\u00eda antigua <code>M5Core2.h</code>. Conc\u00e9ntrate solo en las funciones usadas en <code>button_example.ino</code>.</p> <p>Pregunta: - \u00bfC\u00f3mo se comportan los botones? - \u00bfQu\u00e9 hacen las funciones <code>wasReleased</code> y <code>pressedFor</code>?</p>"},{"location":"real-time_embedded_systems/lab6_1/spanish/#parte-2-codigo-secreto","title":"Parte 2 - C\u00f3digo secreto","text":"<p>El programa tendr\u00e1 4 estados:</p> <ul> <li>Estado 0: No se ha pulsado ning\u00fan bot\u00f3n.</li> <li>Estado 1: Se ha pulsado correctamente el primer bot\u00f3n.</li> <li>Estado 2: Se ha pulsado correctamente el segundo bot\u00f3n.</li> <li>Estado 3: Se ha pulsado correctamente el tercer bot\u00f3n.</li> </ul> <p>Los botones deben presionarse en la secuencia A, B, C.</p> <ul> <li>Si se pulsa el bot\u00f3n correcto, el programa avanza al siguiente estado.</li> <li>Si se pulsa un bot\u00f3n incorrecto, se vuelve al Estado 0.</li> </ul> <p>Ejemplo: Cada vez que cambie el estado, debe imprimirse un mensaje en la pantalla. Por ejemplo: - Si el programa est\u00e1 en el Estado 1: </p><pre><code>    M5.Lcd.println(\"Primer bot\u00f3n correcto\");\n</code></pre> - Si el programa est\u00e1 en el Estado 3: <pre><code>M5.Lcd.println(\"\u00a1C\u00d3DIGO CORRECTO!\");\n</code></pre>"},{"location":"real-time_embedded_systems/lab6_1/spanish/#2-trabajando-en-simulacion","title":"2. Trabajando en simulaci\u00f3n","text":"<p>Puedes hacer un ejercicio similar en simulaci\u00f3n.</p>"},{"location":"real-time_embedded_systems/lab6_2/","title":"Lab Session 6-II: Multitasking with FreeRTOS","text":""},{"location":"real-time_embedded_systems/lab6_2/#lab-session-6-ii-multitasking-with-freertos","title":"Lab Session 6-II: Multitasking with FreeRTOS","text":"<p>Estimated time: 1.5 h (1 session)</p>"},{"location":"real-time_embedded_systems/lab6_2/#1-working-with-real-hardware","title":"1. Working with real hardware","text":""},{"location":"real-time_embedded_systems/lab6_2/#11-test-the-imu-inertial-sensor","title":"1.1 Test the IMU (inertial sensor)","text":"<p>Read and run the program <code>IMU.ino</code> to understand how to work with the M5Core2 sensor.</p>"},{"location":"real-time_embedded_systems/lab6_2/#12-test-the-vibration-motor","title":"1.2 Test the vibration motor","text":"<p>Read and run the program <code>vibration.ino</code> to understand how to work with the actuator on the M5Core2.</p>"},{"location":"real-time_embedded_systems/lab6_2/#13-multitasking-with-sensor-and-actuator","title":"1.3 Multitasking with sensor and actuator","text":"<p>Create a sketch for the M5Core2 using FreeRTOS that does the following:</p> <ol> <li>Use 4 tasks. Initially all tasks run on core 0.</li> <li>Task 1 monitors button presses for buttons <code>A</code>, <code>B</code> and <code>C</code>. It has priority 2 and runs at 100 Hz.</li> <li>Task 2 writes IMU data to the M5 screen similarly to the program <code>IMU.ino</code>. In this case, the data are displayed only when button <code>B</code> has been pressed. If pressed again, the screen remains in its current state (data are not updated). Pressing <code>B</code> again resumes updates, and so on. This task has priority 1 and runs at 25 Hz.</li> <li>Task 3 triggers a vibration pattern as an alarm if acceleration magnitude reaches or exceeds 2 G (sqrt(accXaccX + accYaccY + accZ*accZ) &gt; 2). The pattern should make the motor vibrate 5 times with 200 ms intervals. This task has priority 3 and runs at 5 Hz.</li> <li>The final task writes to the serial port every change that occurs in the application. It only writes if an event has occurred (button <code>A</code>, <code>B</code> or <code>C</code> press, or a vibration alarm). The published data are:</li> <li>How many times <code>A</code> has been pressed.</li> <li>How many times <code>C</code> has been pressed.</li> <li>If <code>B</code> has been pressed and IMU data are currently being displayed, write: \"Using IMU data\". Otherwise write: \"Not using IMU data\".</li> </ol> <p>Question</p> <p>Since the device has 2 cores, you could distribute tasks between them to balance load. For the tasks above: - which task(s) would you assign to each core and why? - Try running the program with those changes and observe any differences in behavior.</p>"},{"location":"real-time_embedded_systems/lab6_2/#2-working-in-simulation","title":"2. Working in simulation","text":"<p>To do this lab in simulation you can use the ESP32 with the following substitutes:</p> <ul> <li>Three external buttons to act as buttons <code>A</code>, <code>B</code>, and <code>C</code>. Configure external interrupts for them.</li> <li>For the IMU, add an external sensor. In Wokwi you can use the <code>mpu6050</code> IMU. See its documentation here. Communication between the IMU and the ESP32 is done via I2C. An Arduino example is available here.</li> <li>Wokwi does not include a vibration motor for the 2G alarm. Replace it with an LED that blinks or varies intensity using PWM duty cycle.</li> <li> <p>To display data on screen you have two options:</p> </li> <li> <p>The simplest: send the data over the serial port.</p> </li> <li>If you prefer, use a TFT display similar to the M5Core2 screen (covered in the next topic). Wokwi provides an ILI9341 TFT you can use. See the documentation here. Example projects here and here.</li> </ul>"},{"location":"real-time_embedded_systems/lab6_2/spanish/","title":"Sesi\u00f3n de Laboratorio 6-II: Multitarea con freeRTOS","text":""},{"location":"real-time_embedded_systems/lab6_2/spanish/#sesion-de-laboratorio-6-ii-multitarea-con-freertos","title":"Sesi\u00f3n de Laboratorio 6-II: Multitarea con freeRTOS","text":"<p>Tiempo estimado: 1,5 h (1 sesi\u00f3n)</p>"},{"location":"real-time_embedded_systems/lab6_2/spanish/#1-trabajando-con-hardware-real","title":"1. Trabajando con hardware real","text":""},{"location":"real-time_embedded_systems/lab6_2/spanish/#11-probar-imu-sensor-inercial","title":"1.1 Probar IMU (sensor inercial)","text":"<p>Lee y lanza el programa `IMU.ino para entender c\u00f3mo trabajar con el sensor en M5Core2.</p>"},{"location":"real-time_embedded_systems/lab6_2/spanish/#12-probar-motor-vibracion","title":"1.2. Probar motor vibraci\u00f3n","text":"<p>Lee y lanza el programa <code>vibration.ino</code> para entender c\u00f3mo trabajar con el actuador en M5Core2.</p>"},{"location":"real-time_embedded_systems/lab6_2/spanish/#13-multitarea-con-sensor-y-actuador","title":"1.3. Multitarea con sensor y actuador","text":"<p>Haz un script para M5Core2 usando FreeRTOS que haga lo siguiente:</p> <ol> <li>Se van a utilizar 4 tareas. En principio, todas se ejecutar\u00e1n en el core 0.</li> <li>La tarea 1 sirve para monitorizar la pulsaci\u00f3n de los botones <code>A</code>, <code>B</code> y <code>C</code>. Tendr\u00e1 prioridad 2 y se ejecutar\u00e1 con una frecuencia de 100Hz.</li> <li>La tarea 2 escribir\u00e1 los datos de la IMU en la pantalla del M5, de forma similar al programa <code>IMU.ino</code>. En este caso, los datos se escribir\u00e1n cuando se haya pulsado el bot\u00f3n <code>B</code>. Si se vuelve a pulsar, la pantalla se queda en el estado actual. Es decir, los datos no se actualizan. Si se pulsa de nuevo, se volver\u00e1n a mostrar. Y as\u00ed, sucesivamente. Esta tarea tendr\u00e1 prioridad 1 y se ejecutar\u00e1 con una frecuencia de 25Hz.</li> <li>La tarea 3 establece un patr\u00f3n de vibraci\u00f3n a modo de alarma si se ha alcanzado una aceleraci\u00f3n igual o superior a 2G <code>sqrt(accX*accX + accY*accY + accZ*accZ &gt; 2)</code>. El patr\u00f3n har\u00e1 que el motor vibre 5 veces con un intervalo de 200ms. Tendr\u00e1 prioridad 3 y se ejecutar\u00e1 con una frecuencia de 5Hz.</li> <li> <p>La \u00faltima tarea escribir\u00e1 por el puerto serie cada cambio ocurrido en la aplicaci\u00f3n. S\u00f3lo escribir\u00e1 si ha ocurrido alg\u00fan evento (pulsaci\u00f3n bot\u00f3n <code>A</code>, <code>B</code> o <code>C</code>, o vibraci\u00f3n). Los datos a publicar son los siguientes:</p> <ul> <li>Cu\u00e1ntas veces se ha pulsado <code>A</code>.</li> <li>Cu\u00e1ntas veces se ha pulsado <code>C</code>.</li> <li>Si se ha pulsado <code>B</code> y se est\u00e1n publicando los datos de la IMU, escribir\u00e1: <code>\"Usando datos IMU\"</code>. En caso contrario: <code>\"No usando datos IMU\"</code></li> </ul> </li> </ol> <p>PREGUNTA:</p> <ul> <li>Como el dispositivo tiene 2 n\u00facleos, se podr\u00edan emplear ambos para balancear mejor la carga de las tareas. De todas las tareas anteriores, \u00bfQu\u00e9 tarea/s pondr\u00edas en cada n\u00facleo? \u00bfPor qu\u00e9? Prueba a ejecutar el programa cambiando dichas tareas y comprueba si hay alguna diferencia en el comportamiento.</li> </ul>"},{"location":"real-time_embedded_systems/lab6_2/spanish/#1-trabajando-en-simulacion","title":"1. Trabajando en simulaci\u00f3n","text":"<p>Para hacer esta pr\u00e1ctica en simulaci\u00f3n se puede trabajar con el ESP32 de la siguiente manera:</p> <ul> <li>Tres botones externos que hagan de botones <code>A</code>, <code>B</code>, y <code>C</code>. Habr\u00e1 que configurar las interrupciones externas.</li> <li>Para trabajar con la IMU hay que a\u00f1adir una externa. En wokwi se puede utilizar la IMU mpu6050. Aqu\u00ed se puede ver la documentaci\u00f3n. La comunicaci\u00f3n IMU-ESP32 se har\u00e1 por I2C. Aqu\u00ed pod\u00e9is encontrar en ejemplo con Arduino.</li> <li>En wokwi no hay un motor de vibraci\u00f3n para la alerta cuando la aceleraci\u00f3n sea mayor de 2G. Este motor se puede sustituir por un LED parpadee o que var\u00ede su intensidad usando diferentes valores del duty cycle de una PWM.</li> <li>Para escribir los datos por pantalla hay dos opciones:<ol> <li>Lo m\u00e1s sencillo es enviarlos por el puerto serie.</li> <li>Si se quiere, se puede utilizar una pantalla TFT similar a la que tiene el M5Core2 (esto lo haremos en el siguiente tema). Wokwi dispone de una pantalla TFT que se puede utilizar. Aqu\u00ed se puede ver la documnetaci\u00f3n. Pod\u00e9is encontrar ejemplos de uso de esa esa pantalla aqu\u00ed y aqu\u00ed.</li> </ol> </li> </ul>"},{"location":"real-time_systems_control/","title":"Introduction","text":""},{"location":"real-time_systems_control/#real-time-systems-control","title":"Real-Time Systems Control","text":"<ul> <li> <p>Lab Session 5: Real-Time Systems Control.</p> <p>Here, you will explore the fundamentals of real-time control systems.</p> </li> </ul>"},{"location":"real-time_systems_control/lab5/","title":"Lab 5: Real-time Systems Control","text":""},{"location":"real-time_systems_control/lab5/#lab-5-real-time-systems-control","title":"Lab 5: Real-time Systems Control","text":"<p>Estimated time: 3 h (2 sessions)</p> <p>Using the code from Labs 2, 3 and 4 and the material from Lecture 4, implement a PID controller inside the microcontroller to perform position control of the DC motor.</p> <p>Warning</p> <p>Ensure that the direction considered as positive when sending the PWM matches the positive rotation direction when reading the encoder. Otherwise you would be implementing the equivalent of a control loop with positive feedback.</p> <p>Tip</p> <p>Carry out the lab following these steps:</p> <ol> <li>Assemble the circuit from Lab 3.</li> <li>Test the Lab 3 code and verify it works correctly.</li> <li>Without dissasembling the existing wiring, assemble the circuit from Lab 4 and verify it works correctly.</li> <li>Work on the Lab 5 software only after verifying that the hardware is correct and both PWM output and encoder reading work properly.</li> </ol> <p>The serial port must be programmed to receive the reference (desired position) from the PC using the Serial Monitor. You can use the following snippet in <code>loop()</code>:</p> <pre><code>int readRef = Serial.parseInt(); // Introduces a delay in the loop, replaces a delay()\nif (readRef != 0) {\n    ref = readRef;\n}\n</code></pre> <p>Adjust the PID parameters manually to minimize overshoot.</p> <p>Tip</p> <p>To properly tune the PID controller, start with the proportional gain <code>Kp</code>, leaving the other parameters at zero. Once Kp is tuned, try adjusting the derivative <code>Kd</code>. To reduce possible steady-state error, assign a small value to the integrator <code>Ki</code> to compensate for any motor deadband.</p>"},{"location":"real-time_systems_control/lab5/spanish/","title":"Pr\u00e1ctica 5: Control de sistemas en tiempo real","text":""},{"location":"real-time_systems_control/lab5/spanish/#practica-5-control-de-sistemas-en-tiempo-real","title":"Pr\u00e1ctica 5: Control de sistemas en tiempo real","text":"<p>Tiempo estimado: 3h (2 sesiones)</p> <p>Usando los c\u00f3digos de las pr\u00e1cticas 2, 3 y 4 y lo expuesto en el Tema 4, implementar un controlador PID dentro del microcontrolador de forma que se realice un control en posici\u00f3n del motor CC.</p> <p>Importante: Asegurarse de que lo que se considera sentido de giro positivo a la hora de enviar el PWM coincide con el sentido de giro positivo a la hora de leer del enc\u00f3der. De lo contrario, se estar\u00eda haciendo el equivalente a un bucle de control con realimentaci\u00f3n positiva.</p> <p>Recomendaci\u00f3n: Realizar la pr\u00e1ctica siguiendo los siguientes pasos:</p> <ol> <li>Montar el circuito de la pr\u00e1ctica 3.</li> <li>Probar el c\u00f3digo de la pr\u00e1ctica 3 y verificar que funciona correctamente.</li> <li>Sin desmontar lo que ya tienes, montar el circuito de la pr\u00e1ctica 4 y verificar que funciona correctamente.</li> <li>Trabajar en el software de la pr\u00e1ctica 5 habiendo verificado que el hardware es correcto y que tanto el env\u00edo de PWM como la lectura del enc\u00f3der funciona correctamente.</li> </ol> <p>Se debe programar el puerto serie para recibir la referencia (posici\u00f3n deseada) a trav\u00e9s del ordenador empleando el \u201cMonitor serie\u201d. Para ello se puede hacer uso del siguiente trozo de c\u00f3digo en el <code>loop()</code>:</p> <pre><code>int readRef = Serial.parseInt(); //Introduce el retraso en el bucle, sustituye a un delay\nif(readRef != 0){  \n    ref = readRef;\n}\n</code></pre> <p>Ajustar los par\u00e1metros PID manualmente de forma que se minimice la sobreoscilaci\u00f3n.</p> <p>Recomendaci\u00f3n: Para ajustar correctamente el controlador PID, comenzar con la ganacia proporcional <code>Kp</code>, dejando el resto de par\u00e1metros a cero. Una vez ajustado este par\u00e1metro, probar a modificar el derivador <code>Kd</code>. Con el fin de reducir el posible error en r\u00e9gimen permanente, se puede asignar un valor peque\u00f1o al integrador <code>Ki</code> para anular la posible zona muerta que pudiera tener el motor.</p>"}]}