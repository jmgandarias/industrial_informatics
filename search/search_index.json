{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"# Industrial Informatics  *Course material for the second part and Lab sesions of the Industrial Informatics course at [the University of M\u00e1laga](https://www.uma.es).*   By [Juan M. Gandarias](https://jmgandarias.com)   Systems Engineering and Automation Department  [Find out more...](./about/README.md)"},{"location":"about/","title":"Welcome","text":""},{"location":"about/#welcome","title":"Welcome","text":"<p>This is the home of the Industrial Informatics course: A fourth-year undergraduate course for Electronics Engineering students in the School of Industrial Engineering at the University of M\u00e1laga.  The content of this website is being developed by Prof. Juan M. Gandarias, an Assistant Professor in the Systems Engineering and Automation Department. The course of Industrial Informatics and its content at the University is given by Prof. Carlos P\u00e9rez-de-Pulgar and Prof. Juan M. Gandarias.</p>"},{"location":"about/#course-content","title":"Course content","text":"<ul> <li>Intro to the course</li> <li>Microcontrollers programming</li> <li>Real-Time Control Systems</li> <li>Real-Time in Embedded Systems</li> <li>Human-Machine Interfaces</li> <li>Internet of Things with MQTT</li> </ul>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>The delivery of these materials following this format has been inspired by the work done by Dr. Tom Howard in the COM2009-3009 Robotics Course at The University of Sheffield. In addition, the content presented has been inspired by various sources listed below.</p>"},{"location":"about/acknowledgements/#general","title":"General","text":"<ul> <li>Luis LLamas Tutorials.</li> <li>Arduino.</li> <li>ESP-IDF.</li> <li>M5Stack.</li> <li>Wokwi.</li> <li>FreeRTOS.</li> </ul>"},{"location":"about/acknowledgements/#real-time-control-systems","title":"Real-Time Control Systems","text":"<ul> <li>W. Bolton, \u201cMecatr\u00f3nica, Sistemas de control electr\u00f3nico en la ingenier\u00eda mec\u00e1nica y el\u00e9ctrica\u201d, Ed. Marcombo, 2010.\u200b</li> <li>S. Bennett, \u201cReal-Time Computer Control, An Introduction\u201d, Ed. Prentice Hall, 1994.\u200b</li> <li>A. Alonso y A. Crespo Lorente, \u201cUna panor\u00e1mica de los Sistemas de Tiempo Real,\u201d Revista Iberoamericana de Autom\u00e1tica e Inform\u00e1tica Industrial, vol. 3, n.o 2, p\u00e1gs. 7-18, 2010.</li> </ul>"},{"location":"about/acknowledgements/#real-time-embedded-systems","title":"Real-Time Embedded Systems","text":"<ul> <li>J. R. Z. Flores, \u201cPlanificaci\u00f3n est\u00e1tica de procesos en sistemas de tiempo real cr\u00edtico,\u201d Tesis doct., Universidad Polit\u00e9cnica de Madrid, 1995.\u200b</li> <li>A. Burns y A. J. Wellings, Real-time systems and programming languages: Ada 95, real-time Java, and real-time POSIX. 2001.\u200b</li> <li>J. W. Liu, Real-time systems. 2006.\u200b</li> </ul>"},{"location":"about/acknowledgements/#hmi","title":"HMI","text":"<ul> <li>J. Raskin, The humane interface: new directions for designing interactive systems. Addison-Wesley Professional, 2000. \u200b</li> <li>J. W. Satzinger y L. Olfman, \u201cUser interface consistency across end-user applications: the effects on mental models,\u201d Journal of Management Information Systems, vol. 14, n.o 4, p\u00e1gs. 167-193, 1998.</li> </ul>"},{"location":"about/acknowledgements/#mqtt","title":"MQTT","text":"<ul> <li>R. Buyya y A. V. Dastjerdi, Internet of Things: Principles and paradigms. Elsevier, 2016.</li> <li>K. Ashton et al., \u201cThat \u2018internet of things\u2019 thing,\u201d RFID journal, vol. 22, n.o 7, p\u00e1gs. 97-114, 2009.</li> <li>Fremantle et al., \u201cA reference architecture for the internet of things,\u201d WSO2 White paper, p\u00e1gs. 02-04, 2015.</li> <li>Y. Zhang y F. Tao, Optimization of manufacturing systems using the Internet of Things. Academic Press, 2016.</li> <li>M. Schwartz, Internet of Things with ESP8266. Packt Publishing Ltd, 2016.</li> <li>T. Pulver, Hands-On Internet of Things with MQTT: Build connected IoT devices with Arduino and MQ Telemetry Transport (MQTT). Packt Publishing Ltd, 2019.</li> <li>L. R. Kanagachidambaresan, Internet of Things Using Single Board Computers: Principles of IoT and Python Programming. Springer, 2022.</li> </ul>"},{"location":"about/changelog/","title":"Version History","text":""},{"location":"about/changelog/#iteration-2","title":"Iteration 2","text":"<p>Academic Year: 2025-2026</p> <ul> <li>All lab sessions included.</li> <li>First version of getting started.</li> <li>WIP documentation.</li> </ul>"},{"location":"about/changelog/#iteration-1","title":"Iteration 1","text":"<p>Academic Year: 2024-2025</p> <ul> <li>Initial release of the material.</li> <li>Included MQTT material only (for now...).</li> </ul>"},{"location":"about/license/","title":"License","text":"<p> This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. </p> <p>You are free to distribute, remix, adapt, and build upon this work (for non-commercial purposes only) as long as credit is given to the original author.</p> <p>For more information, check this link.</p>"},{"location":"hmi/","title":"KMI","text":""},{"location":"hmi/#human-machine-interfaces","title":"Human-Machine Interfaces","text":"<ul> <li> <p>Lab Session 7: TFT LCD Screen.</p> <p>In this exercise you will learn how to simulate microcontrollers with Wokwi.</p> </li> </ul>"},{"location":"hmi/lab7/","title":"Lab Session 7: TFT LCD Screen","text":""},{"location":"hmi/lab7/#lab-session-7-tft-lcd-screen","title":"Lab Session 7: TFT LCD Screen","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"hmi/lab7/#1-title","title":"1. Title","text":""},{"location":"intro/","title":"Introduction","text":""},{"location":"intro/#introduction-to-the-course","title":"Introduction to the course","text":"<ul> <li> <p>Getting started: An introduction to the course.</p> <p>This page summarizes the prerequisites of the course</p> </li> <li> <p>Lab Session 0: Initial steps.</p> <p>In this exercise you will learn how to simulate microcontrollers with Wokwi and how to setup the Arduino IDE for the course.</p> </li> </ul>"},{"location":"intro/getting_started/","title":"Getting Started","text":""},{"location":"intro/getting_started/#getting-started","title":"Getting Started","text":""},{"location":"intro/getting_started/#1-what-is-a-microcontroller","title":"1. What is a Microcontroller?","text":"<p>A microcontroller is a compact integrated circuit designed to perform specific tasks within an embedded system. Unlike general-purpose computers, microcontrollers are optimized for controlling devices, sensors, and actuators in real-time applications. Key characteristics:</p> <ul> <li>Low power consumption</li> <li>Real-time processing capabilities</li> <li>Integration of CPU, memory, and peripherals on a single chip</li> </ul> <p>Microcontrollers are widely used in automation, robotics, IoT devices, and industrial control systems.</p>"},{"location":"intro/getting_started/#2-course-hardware-and-tools","title":"2. Course Hardware and Tools","text":"<p>In this course, we will use the following components and tools:</p>"},{"location":"intro/getting_started/#21-esp32-microcontroller","title":"2.1. ESP32 Microcontroller","text":"<p>The ESP32 is a powerful and versatile microcontroller featuring:</p> <ul> <li>Dual-core processor</li> <li>Built-in Wi-Fi and Bluetooth</li> <li>Multiple GPIO pins for sensors and actuators</li> <li>Support for various communication protocols (I2C, SPI, UART)</li> </ul>"},{"location":"intro/getting_started/#22-wokwi-simulator","title":"2.2. Wokwi Simulator","text":"<p>Wokwi is an online simulator that allows you to:</p> <ul> <li>Prototype circuits without physical hardware</li> <li>Test and debug Arduino, ESP32, and other microcontrollers projects</li> <li>Visualize sensor and actuator behavior in simulated real-time</li> </ul>"},{"location":"intro/getting_started/#23-arduino-ide","title":"2.3. Arduino IDE","text":"<p>The Arduino Integrated Development Environment (IDE) will be our main programming tool. It provides:</p> <ul> <li>A simple interface for writing and uploading code</li> <li>Extensive libraries for sensors, displays, and communication</li> <li>Cross-platform compatibility (Windows, macOS, Linux)</li> </ul>"},{"location":"intro/getting_started/#24-m5core2-development-kit","title":"2.4. M5Core2 Development Kit","text":"<p>The M5Core2 is an ESP32-based device with:</p> <ul> <li>A touchscreen display</li> <li>Built-in sensors and expansion ports</li> <li>A modular design for rapid prototyping</li> </ul>"},{"location":"intro/getting_started/#3-additional-programming-material","title":"3. Additional Programming Material","text":"<p>If you don't feel confident enough to follow the content of this course due to lack of programming knowledge, or maybe you've taken a course on coding before but it's been a while since since then and don't remember well how to do it, here you have some extra material that could help you.</p> <p>In this course we'll code ESP32-based microcontrollers in C/C++ usign the Arduino IDE.</p> <p>There are several sources of information in the internet you could use for free. Here are the ones I find the most useful for the purpose of this course:</p>"},{"location":"intro/getting_started/#31-learn-c","title":"3.1. Learn C++","text":"<p>In this website you have all the necessary information on how to program in C++. Including many elements that go beyond the content of this course.</p>"},{"location":"intro/getting_started/#32-luis-llamas-introduction-to-programming-course","title":"3.2. Luis Llamas' Introduction to Programming Course","text":"<p>This is a course that covers general topics of programming (you can find it in Engish and Spanish). In many of the entries you can find examples in different languages (don't forget to select C/C++). The list below shows:</p> <ol> <li>The Minimum concepts you should know before taking this course. Without this knowledge, it'd be hard for you to follow this course.</li> <li>The Desired concepts to have before taking this course. It completes the previous list and if you have them, you'll be able to follow the course without any problem.</li> <li>The Advanced concepts. It completes the two preivious lists. If you have the, your code knowdlege exceedes the required for this course.</li> </ol>"},{"location":"intro/getting_started/#321-minimum-concepts","title":"3.2.1. Minimum concepts","text":"<ol> <li> <p>Introduction</p> <ul> <li>What is programming</li> <li>Brief history of programming</li> <li>Evolution of languages</li> <li>Software development phases</li> </ul> </li> <li> <p>Fundamentals</p> <ul> <li>Types of programs</li> </ul> </li> <li> <p>Frequent Concepts</p> <ul> <li>What is a library</li> <li>What are dependencies</li> <li>Semantic versioning</li> <li>Packages and package managers</li> </ul> </li> <li> <p>Tools</p> <ul> <li>What is an IDE</li> </ul> </li> <li> <p>Program Structure</p> <ul> <li>Program structure</li> <li>Program lifecycle</li> <li>Statements and blocks</li> <li>What is indentation</li> <li>What are comments</li> </ul> </li> <li> <p>Expressions and Operators</p> <ul> <li>Operators and expressions</li> <li>Operator precedence</li> <li>Access operators</li> <li>Assigment operators</li> <li>Arithmetic operators</li> <li>Comparison operators</li> <li>Logical operators</li> </ul> </li> <li> <p>Variables</p> <ul> <li>What is a variable</li> <li>What is a constant</li> </ul> </li> <li> <p>Data Types</p> <ul> <li>Data types</li> <li>Typed and untyped languages</li> </ul> </li> <li> <p>Common types</p> <ul> <li>Boolean</li> <li>Numeric</li> <li>Text</li> </ul> </li> <li> <p>Control Flow</p> <ul> <li>what is control flow</li> <li>Go-to statemet</li> <li>What is a conditional</li> <li>What is a loop</li> </ul> </li> <li> <p>Conditionals</p> <ul> <li>If</li> <li>If-else</li> <li>If-elseif</li> <li>Switch</li> </ul> </li> <li> <p>Loops</p> <ul> <li>While</li> <li>Do-while</li> <li>For</li> </ul> </li> <li> <p>Functions</p> <ul> <li>What is a function</li> </ul> </li> </ol>"},{"location":"intro/getting_started/#322-desired-concepts","title":"3.2.2. Desired concepts","text":"<ol> <li> <p>Fundamentals</p> <ul> <li>Machine code</li> </ul> </li> <li> <p>Tools</p> <ul> <li>Top IDEs</li> <li>Source code control</li> </ul> </li> <li> <p>Variables</p> <ul> <li>Variable scope</li> </ul> </li> <li> <p>References</p> <ul> <li>What is a reference</li> <li>Type value and reference</li> <li>Parameters by value or reference</li> </ul> </li> <li> <p>Conditionals</p> <ul> <li>Nested conditionals</li> </ul> </li> <li> <p>Loops</p> <ul> <li>Nested loops</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Function Parameters</li> <li>Function return value</li> <li>Function overloading</li> </ul> </li> <li> <p>Collections</p> <ul> <li>Arrays</li> </ul> </li> <li> <p>Data Structures</p> <ul> <li>Structs</li> </ul> </li> </ol>"},{"location":"intro/getting_started/#323-advanced-concepts","title":"3.2.3. Advanced concepts","text":"<ol> <li> <p>Fundamentals</p> <ul> <li>Assembly language</li> </ul> </li> <li> <p>Tools</p> <ul> <li>Visual Studio Code</li> <li>Node.js</li> <li>NPM</li> </ul> </li> <li> <p>Variables</p> <ul> <li>Destructuring</li> </ul> </li> <li> <p>Data Types</p> <ul> <li>Type deduction</li> </ul> </li> <li> <p>Common types</p> <ul> <li>Time</li> <li>Enums</li> <li>Collection</li> <li>Grouping</li> </ul> </li> <li> <p>References</p> <ul> <li>Function references</li> </ul> </li> <li> <p>Control Flow</p> <ul> <li>Exceptions and Try-Catch</li> </ul> </li> <li> <p>Conditionals</p> <ul> <li>Ternary operator</li> </ul> </li> <li> <p>Loops</p> <ul> <li>Foreach</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Lambda functions</li> <li>Recursive functions</li> <li>Passing functions as parameters</li> </ul> </li> <li> <p>Collections</p> <ul> <li>Dynamic arrays</li> <li>HashSet</li> <li>Dictionaries</li> <li>LinkedLists</li> <li>Stacks</li> <li>Queue</li> <li>Efficiency of collections</li> </ul> </li> <li> <p>Data Structures</p> <ul> <li>Objects</li> <li>Object oriented programming</li> <li>Tuples</li> <li>Graphs</li> <li>Trees</li> </ul> </li> <li> <p>Asynchrony</p> <ul> <li>Asynchronous programming (we'll see it in Lecture 6)</li> <li>Concurrency and Paralellism (we'll see it in Lecture 6)</li> </ul> </li> </ol>"},{"location":"intro/getting_started/#4-additional-esp32-material","title":"4. Additional ESP32 Material","text":"<p>More material about how to program microcontrollers (ESP32, in particular) can be found in Luis Llamas' website, here and here. Some of this material will be covered in our course.</p>"},{"location":"intro/lab0/","title":"Lab Session 0: Initial steps","text":""},{"location":"intro/lab0/#lab-session-0-initial-steps","title":"Lab Session 0: Initial steps","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"intro/lab0/#1-microcontrollers-simulation","title":"1. Microcontrollers simulation","text":""},{"location":"intro/lab0/#launch-an-example","title":"Launch an example","text":"<ul> <li>Access the Wokwi simulation environment via this link.</li> <li> <p>Select the ESP32 template.</p> <p> </p> <p>Warning</p> <p>Open the ESP32 template from <code>Starter Templates</code>, not from <code>ESP-IDF Templates</code>. The former is based on the Arduino IDE while the latter is based on the ESP-IDF environment that will not be used in the course.</p> </li> <li> <p>Simulate the example sketch:</p> <pre><code>void setup() {\n// put your setup code here, to run once:\nSerial.begin(115200);\nSerial.println(\"Hello, ESP32!\");\n}\n\nvoid loop() {\n// put your main code here, to run repeatedly:\ndelay(10); // this speeds up the simulation\n}\n</code></pre> <p>Warning</p> <p>Here you are simulating the behavior of the system including the code, you are not compiling the code (i.e., we're not generating the machine-readable code that will be executed by a processor). But the code MUST be compliable (i.e., it will be verified to check that I would compile )</p> <p>Info</p> <ul> <li>Note that the real-time factor at the top right corner should be as close as possible to 100%. This value is a simulation performance metric. The closer it gets to 100%, the better is the simulation. A value of 100% means the simulation is running in real-time. If the value drops, the times in the simulation are no longer reliable.</li> <li>Note the instruction <code>delay(10); // this speeds up the simulation</code>. Try to comment this line and see what happens. What if you put <code>delay(1);</code> or <code>delay(5);</code>?</li> </ul> <p>Question</p> <ul> <li>What is the purpose of the <code>setup()</code> function?</li> <li>What is the purpose of the <code>loop()</code> function?</li> <li>What does the <code>delay()</code> function do?</li> <li>Why do we need to put the <code>delay(10)</code> inside the <code>loop()</code> function?</li> </ul> </li> </ul>"},{"location":"intro/lab0/#add-hardware-components","title":"Add hardware components","text":"<ul> <li> <p>First of all, check the <code>diagram.json</code> file . What information do you see there?</p> </li> <li> <p>Connect an LED to <code>GPIO 21</code> with a resistor, as shown in the diagram (rotate - R and flip - P components if necessary).</p> <p></p> <p>Question</p> <ul> <li>Check again the <code>diagram.json</code>. What happened? Can you change the color of the LED to green from this file?</li> <li>What do you think you can do with the Library Manager?</li> </ul> </li> </ul>"},{"location":"intro/lab0/#2-prepare-the-arduino-ide","title":"2. Prepare the Arduino IDE","text":"<p>Follow the installation steps described in this guide.</p> <ol> <li>Install Arduino IDE: Download it from this link.</li> <li> <p>Install the M5Stack board family:</p> <p></p> <p>You need to copy/paste this text to download the board package</p> <pre><code>https://static-cdn.m5stack.com/resource/arduino/package_m5stack_index.json \n</code></pre> <p></p> <p>Once the board package address is set, you can install it from the boards manager. </p> <p>Warning</p> <p>Remember to install the version 2.1.4. If you try to install version 3.X you won't be able to do exercises of the lab sessions. We'll talk about the versions 2.X and 3.X later and how to migrate our code from one to another. For now, just use the 2.X version.</p> <p>Danger</p> <p>Once you've done this, if you open the Arduino IDE later, a message will pop up letting you know that there are updates available for some libraries and asking whether you want to install the updates or not. Don't update the libraries</p> <p>Info</p> <p>This process may take a few minutes.</p> <p>Once installed, you can select M5Core2 from the board selection menu.</p> <p></p> </li> <li> <p>Install the Arduino libraries for M5Core2:</p> <p></p> <p>Warning</p> <p>When you press Install, you'll see the list of dependencies. You MUST install all the dependencies too.</p> <p>Info</p> <p>This is a long process that may take several minutes. Be patient...</p> <p>Tip</p> <p>In case the list of dependencies is that large that you cannot see the Install All button, you can press the tab key Tab twice to put the cursor over the button and then press Enter to install all the dependencies.</p> </li> <li> <p>Install the CP2104 driver (USB driver):</p> <p>Download it from this link if you're using Windows, from this link if you're using MacOS, or from this other link if you're using Linux.</p> <p>More info about USB driver installation here.</p> <p>Now, when you connect the M5Core2 devide to the PC with the USB cable, you can select the port in the Arduino IDE.</p> <p></p> <p>Info</p> <ul> <li>In windows, the port is called COMX, where X is a number that can vary from time to time, e.g., COM5.</li> <li>In linux, the port is called \"ttyUSBX\" or \"ttyACMX\", where X is a number that can vary from time to time, e.g., ttyUSB2.</li> </ul> </li> <li> <p>Compile and upload the <code>hello_world.ino</code> example from M5Core2 library:</p> <p></p> <p>You can press the Upload (in red) button to compile and load the program to the device. Note that the button on the left (Verify - in green) compiles the program but doesn't upload it to the device.</p> <p></p> </li> <li> <p>OPTIONAL (do it ONLY if you have finished all the exercises of the lab session): You can open other examples if you want to see the potential of M5Core2. You can try this one:</p> <p></p> </li> </ol> <p>Additional resources</p> <p>Here you can find more documentation about some of the basic functions of M5Core2.  </p> <p>Pinout and Important Notes Below is the M5Core2 pinout. The pins marked in red are the ones we will use in the exercises.</p> <p></p> <p>Warning</p> <ul> <li>Some pins on the M5Core2 are preconfigured, so pay attention when connecting external components.</li> <li>The ESP32 inside the M5Core2 has 3 serial ports:<ul> <li><code>Serial1</code> is reserved for the display (do not use it).</li> <li><code>Serial0</code> can be configured (pins <code>G3 \u2013 RXD0</code> and <code>G1 \u2013 TXD0</code>), but it is reserved for USB connection to the PC.</li> <li><code>Serial2</code> is free and can be configured (pins <code>G13 \u2013 RXD2</code> and <code>G14 \u2013 TXD2</code>) as regular GPIO using <code>pinMode()</code>.</li> </ul> </li> </ul>"},{"location":"intro/lab0/spanish/","title":"Sesi\u00f3n de Laboratorio 0: Primeros pasos","text":""},{"location":"intro/lab0/spanish/#sesion-de-laboratorio-0-primeros-pasos","title":"Sesi\u00f3n de Laboratorio 0: Primeros pasos","text":"<p>Tiempo estimado: 1,5 h (1 sesi\u00f3n)</p>"},{"location":"intro/lab0/spanish/#1-simulacion-de-microcontroladores","title":"1. Simulaci\u00f3n de microcontroladores","text":""},{"location":"intro/lab0/spanish/#ejecutar-un-ejemplo","title":"Ejecutar un ejemplo","text":"<ul> <li>Accede al entorno de simulaci\u00f3n Wokwi a trav\u00e9s de este enlace.</li> <li> <p>Selecciona la plantilla ESP32.</p> <p> </p> <p>NOTA: Abre la plantilla ESP32 desde <code>Starter Templates</code>, no desde <code>ESP-IDF Templates</code>. La primera est\u00e1 basada en el IDE de Arduino, mientras que la segunda est\u00e1 basada en el entorno ESP-IDF que no se usar\u00e1 en el curso.</p> </li> <li> <p>Simula el sketch de ejemplo:</p> <pre><code>void setup() {\n// c\u00f3digo de configuraci\u00f3n, se ejecuta una sola vez:\nSerial.begin(115200);\nSerial.println(\"Hello, ESP32!\");\n}\n\nvoid loop() {\n// c\u00f3digo principal, se ejecuta repetidamente:\ndelay(10); // esto acelera la simulaci\u00f3n\n}\n</code></pre> <p>NOTA: Aqu\u00ed est\u00e1s simulando el comportamiento del sistema, incluido el c\u00f3digo; no est\u00e1s compilando el c\u00f3digo (es decir, no se est\u00e1 generando el c\u00f3digo m\u00e1quina que ejecutar\u00e1 un procesador). Pero el c\u00f3digo DEBE ser compilable (es decir, se verificar\u00e1 que podr\u00eda compilar).</p> <p>INFO: - Observa que el factor de tiempo real en la esquina superior derecha debe estar lo m\u00e1s cerca posible del 100%. Este valor es una m\u00e9trica de rendimiento de la simulaci\u00f3n. Cuanto m\u00e1s cerca est\u00e9 de 100%, mejor ser\u00e1 la simulaci\u00f3n. Un valor del 100% significa que la simulaci\u00f3n se ejecuta en tiempo real. Si el valor baja, los tiempos de la simulaci\u00f3n dejan de ser fiables. - Observa la instrucci\u00f3n <code>delay(10); // esto acelera la simulaci\u00f3n</code>. Prueba a comentar esta l\u00ednea y observa qu\u00e9 ocurre. \u00bfQu\u00e9 pasa si pones <code>delay(1);</code> o <code>delay(5);</code>?</p> <p>PREGUNTA: - \u00bfCu\u00e1l es el prop\u00f3sito de la funci\u00f3n setup()? - \u00bfCu\u00e1l es el prop\u00f3sito de la funci\u00f3n loop()? - \u00bfQu\u00e9 hace la funci\u00f3n delay()? - \u00bfPor qu\u00e9 necesitamos poner delay(10) dentro de la funci\u00f3n loop()?</p> </li> </ul>"},{"location":"intro/lab0/spanish/#anadir-componentes-de-hardware","title":"A\u00f1adir componentes de hardware","text":"<ul> <li> <p>Primero, revisa el archivo <code>diagram.json</code>. \u00bfQu\u00e9 informaci\u00f3n ves all\u00ed?</p> </li> <li> <p>Conecta un LED al <code>GPIO 21</code> con una resistencia, como se muestra en el diagrama (rota - tecla R y voltea - tecla P los componentes si es necesario).</p> <p></p> <p>PREGUNTA: - Revisa de nuevo el <code>diagram.json</code>. \u00bfQu\u00e9 ha cambiado? \u00bfPuedes cambiar el color del LED a verde desde este archivo? - \u00bfQu\u00e9 crees que puedes hacer con el Library Manager?</p> </li> </ul>"},{"location":"intro/lab0/spanish/#2-preparar-el-ide-de-arduino","title":"2. Preparar el IDE de Arduino","text":"<p>Sigue los pasos de instalaci\u00f3n descritos en esta gu\u00eda.</p> <ol> <li>Instala el IDE de Arduino: Desc\u00e1rgalo desde este enlace:</li> <li> <p>Instala la familia de placas M5Stack:</p> <p></p> <p>Necesitas copiar/pegar este texto para descargar el paquete de placas:</p> <pre><code>https://static-cdn.m5stack.com/resource/arduino/package_m5stack_index.json \n</code></pre> <p></p> <p>Una vez configurada la direcci\u00f3n del paquete, puedes instalarlo desde el gestor de placas.</p> <p></p> <p>IMPORTANTE: Recuerda instalar la versi\u00f3n 2.1.4. Si intentas instalar la versi\u00f3n 3.X, no podr\u00e1s realizar los ejercicios de las sesiones de laboratorio. M\u00e1s adelante hablaremos sobre las versiones 2.X y 3.X y c\u00f3mo migrar nuestro c\u00f3digo de una a otra. Por ahora, utiliza \u00fanicamente la versi\u00f3n 2.X.</p> <p>IMPORTANTE: Una vez que hayas hecho esto, si m\u00e1s adelante abres el Arduino IDE, aparecer\u00e1 un mensaje inform\u00e1ndote de que hay actualizaciones disponibles para algunas bibliotecas y pregunt\u00e1ndote si deseas instalarlas o no.     No actualices las bibliotecas.</p> <p>INFO: Este proceso puede tardar unos minutos.</p> <p>Una vez instalado, puedes seleccionar M5Core2 desde el men\u00fa de selecci\u00f3n de placas.</p> <p></p> </li> <li> <p>Instala las librer\u00edas de Arduino para M5Core2:</p> <p></p> <p>NOTA: Cuando pulses Install, ver\u00e1s la lista de dependencias. DEBES instalar tambi\u00e9n todas las dependencias.</p> <p>INFO: Este es un proceso largo que puede tardar varios minutos. Ten paciencia...</p> <p>AYUDA: Si la lista de dependencias es tan grande que no puedes ver el bot\u00f3n Install All, puedes pulsar la tecla tabulador dos veces para poner el cursor sobre el bot\u00f3n y luego pulsar Enter* para instalar todas las dependencias.</p> </li> <li> <p>Instala el driver CP2104 (controlador USB):</p> <p>Desc\u00e1rgalo desde este enlace si usas Windows, desde este enlace si usas MacOS, o desde este otro enlace si usas Linux.</p> <p>M\u00e1s informaci\u00f3n sobre la instalaci\u00f3n del controlador USB aqu\u00ed.</p> <p>Ahora, cuando conectes el dispositivo M5Core2 al PC con el cable USB, podr\u00e1s seleccionar el puerto en el IDE de Arduino. </p> <p>INFO:  - En Windows, el puerto se llama COMX, donde X es un n\u00famero que puede variar, por ejemplo, COM5.  - En Linux, el puerto se llama \"ttyUSBX\" o \"ttyACMX\", donde X es un n\u00famero que puede variar, por ejemplo, ttyUSB2.</p> </li> <li> <p>Compila y sube el ejemplo <code>hello_world.ino</code> de la librer\u00eda M5Core2:</p> <p></p> <p>Puedes pulsar el bot\u00f3n Upload (en rojo) para compilar y cargar el programa en el dispositivo. Observa que el bot\u00f3n de la izquierda (Verify - en verde) compila el programa pero no lo sube al dispositivo.</p> <p></p> </li> <li> <p>OPCIONAL (hazlo SOLO si has terminado todos los ejercicios de la sesi\u00f3n): Puedes abrir otros ejemplos si quieres ver el potencial del M5Core2. Por ejemplo:</p> <p></p> </li> </ol> <p>AYUDA: \"Recursos adicionales\"     Aqu\u00ed puedes encontrar m\u00e1s documentaci\u00f3n sobre algunas funciones b\u00e1sicas del M5Core2.</p> <p>Pinout y notas importantes A continuaci\u00f3n se muestra el pinout del M5Core2. Los pines marcados en rojo son los que usaremos en los ejercicios.</p> <p></p> <p>NOTA:  - Algunos pines del M5Core2 est\u00e1n preconfigurados, as\u00ed que presta atenci\u00f3n al conectar componentes externos.  - El ESP32 dentro del M5Core2 tiene 3 puertos serie:    - <code>Serial1</code> est\u00e1 reservado para la pantalla (no lo uses).    - <code>Serial0</code> se puede configurar (pines <code>G3 \u2013 RXD0</code> y <code>G1 \u2013 TXD0</code>), pero est\u00e1 reservado para la conexi\u00f3n USB al PC.    - <code>Serial2</code> est\u00e1 libre y se puede configurar (pines G13 \u2013 RXD2 y G14 \u2013 TXD2) como GPIO normales usando <code>pinMode()</code>.</p>"},{"location":"microcontrollers_programming/","title":"Introduction","text":""},{"location":"microcontrollers_programming/#microcontrollers-programming","title":"Microcontrollers programming","text":"<ul> <li> <p>Lab Session 1: Intro to microcontrollers programming.</p> <p>Here, you will explore the fundamentals of programming microcontrollers.</p> </li> <li> <p>Lab Session 2: Timers.</p> <p>Here, you will explore how to use timers in microcontrollers.</p> </li> <li> <p>Lab Session 3: PWM.</p> <p>Here, you will explore how to use Pulse Width Modulation (PWM) signals.</p> </li> <li> <p>Lab Session 4: Incremental Encoders.</p> <p>Here, you will explore how to use external interruptions to read incremental encoders.</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/","title":"Lab Session 1: Intro to microcontrollers programming","text":""},{"location":"microcontrollers_programming/lab1/#lab-session-1-intro-to-microcontrollers-programming","title":"Lab Session 1: Intro to microcontrollers programming","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"microcontrollers_programming/lab1/#1-working-in-simulation","title":"1. Working in Simulation","text":""},{"location":"microcontrollers_programming/lab1/#21-turn-an-led-on-and-off","title":"2.1. Turn an LED ON and OFF","text":"<p>Connect an LED as follows:</p> <p></p> <p>Run the following program: </p><pre><code>#define LED_PIN 21\n#define BUTTON_PIN 35\n\nvoid setup() {\n    pinMode(LED_PIN, OUTPUT);\n    pinMode(BUTTON_PIN, INPUT_PULLUP);\n}\n\nvoid loop() {\n    digitalWrite(LED_PIN, HIGH);\n    delay(500);\n    digitalWrite(LED_PIN, LOW);\n    delay(500);\n}\n</code></pre> <p>Question</p> <ul> <li>What does the <code>#define</code> do?</li> <li>What does the <code>pinMode()</code> function do?</li> <li>What does the <code>digitalWrite()</code> function do?</li> </ul>"},{"location":"microcontrollers_programming/lab1/#12-control-the-led-state-with-a-push-button","title":"1.2. Control the LED state with a push button","text":"<ul> <li> <p>Implement the circuit shown in the following diagram and simulate a program that:</p> <ul> <li>Turns the LED ON when the button is pressed.</li> <li>Turns the LED OFF when the button is not pressed.</li> </ul> <p>Tip</p> <ul> <li>Use the function <code>digitalRead()</code> to get the status of the button.</li> <li>You may need to use the <code>if...else</code> condition.</li> </ul> <p></p> <p>Warning</p> <p>When you place the button, don\u2019t forget to deselect the bounce option to avoid bouncing issues.</p> <p></p> <p>Question</p> <ul> <li>What information is included in the <code>diagram.json</code>? Did it change with respect to the previous exercise?  </li> <li>Can you do the exercise without using the <code>if...else</code> condition? How?</li> </ul> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#13-additional-exercises","title":"1.3. Additional exercises","text":""},{"location":"microcontrollers_programming/lab1/#131-blink","title":"1.3.1. Blink","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED while the button is pushed.</p> <p>Tip</p> <p>You may need to use the <code>millis()</code> function.</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#132-short-press-vs-long-press","title":"1.3.2. Short press vs long press","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that does the following:</p> <ul> <li>Short press (&lt; 500 ms): Toggle LED (if the LED is ON, turns it OFF, and viceversa).</li> <li>Long press (\u2265 500 ms): Blink LED.</li> </ul> <p>Tip</p> <p>You may need to use the <code>millis()</code> function, and the  <code>if...else</code> condition.</p> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#2-working-with-real-hardware","title":"2. Working with real hardware","text":""},{"location":"microcontrollers_programming/lab1/#21-turn-an-led-on-and-off_1","title":"2.1. Turn an LED ON and OFF","text":"<p>Connect an LED as follows:</p> <p></p> <p>Run the following program: </p><pre><code>#include &lt;M5Core2.h&gt;\n#define LED_PIN 14\n\nvoid setup() {\n  M5.begin(); // Initialize M5Core2\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(LED_PIN, HIGH);\n  delay(500);\n  digitalWrite(LED_PIN, LOW);\n  delay(500);\n}\n</code></pre> <p>Question</p> <p>Note that you had to include the <code>#include &lt;M5Core2.h&gt;</code> and the <code>M5.begin(); // Initialize M5Core</code> Why did you have to do that? what are these instructions for?</p>"},{"location":"microcontrollers_programming/lab1/#22-additional-exercises","title":"2.2. Additional exercises","text":""},{"location":"microcontrollers_programming/lab1/#221-blink-at-a-certain-frequency","title":"2.2.1. Blink at a certain frequency","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED at a frequency of 10Hz.</p> <p>Question</p> <ul> <li>For how long does the LED has to be ON or OFF in each cycle?</li> </ul> </li> </ul>"},{"location":"microcontrollers_programming/lab1/#222-blink-and-stop","title":"2.2.2. Blink and stop","text":"<ul> <li> <p>Using the same circuit as in the previous exercise, write a script that Blinks the LED at a frequency of 2Hz and stops the blinking after 5 seconds.</p> <p>Question</p> <ul> <li>How many times does the LED blink?</li> <li>What is the final state of the LED when the blink stops, does it remain ON or OFF?</li> </ul> <p>Tip</p> <p>You may need to use the <code>for</code> loop, or the  <code>if...else</code> condition.</p> </li> </ul>"},{"location":"microcontrollers_programming/lab2/","title":"Lab Session 2: Timers","text":""},{"location":"microcontrollers_programming/lab2/#lab-session-2-timers","title":"Lab Session 2: Timers","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"microcontrollers_programming/lab2/#1-description","title":"1. Description","text":"<p>The goal of this session is to learn the different ways a microcontroller can perform timing operations. As seen previously, the <code>delay()</code> function can be used to create a wait for the required amount of time. However, to solve slightly more complex problems, it becomes necessary to use timers, which allow us to interrupt the normal execution of the program in order to handle a periodic event.</p>"},{"location":"microcontrollers_programming/lab2/#2-use-of-an-external-library-ticker","title":"2. Use of an external library - Ticker","text":"<p>The Arduino Ticker Library allows you to create easily Ticker callbacks, which can call a function in a predetermined interval The following example shows how to perform timing operations using the Ticker library and the <code>attach()</code> or <code>attach_ms()</code> functions.</p> <pre><code>#include &lt;M5Core2.h&gt;   // M5Stack Core2 library\n#include &lt;Ticker.h&gt;    // Ticker library\n\n#define LED_PIN 14     // GPIO pin where the LED is connected on the M5Core2\n\nTicker blinker;        // Create a Ticker object. It will call a function at regular intervals.\n\n/*\n  This function (callback) will be called by the Ticker at the configured time interval.\n  It simply toggles the LED state:\n    - digitalRead(LED_PIN) reads the current state (HIGH/LOW)\n    - ! inverts that state\n    - digitalWrite writes the inverted state back to the pin\n*/\nvoid changeState()\n{\n    digitalWrite(LED_PIN, !(digitalRead(LED_PIN))); \n}\n\nvoid setup() \n{\n    M5.begin();          // Initialize the M5Core2 hardware (display, I2C, etc.)\n    pinMode(LED_PIN, OUTPUT); // Configure the LED pin as an output\n\n    // Initialize the Ticker to call changeState() periodically.\n    // attach() accepts time in seconds (here 0.5 s = 500 ms).\n    // If you prefer milliseconds, use attach_ms(milliseconds, callback).\n    blinker.attach(0.5, changeState); \n}\n\nvoid loop() \n{      \n    // Empty: the Ticker handles the periodic LED toggling asynchronously.\n}\n</code></pre> <p>Connect an LED to pin 14 of the M5Core2 and modify this example so that the LED blinks every second instead of every 500 ms.</p> <p></p>"},{"location":"microcontrollers_programming/lab2/#3-use-hardware-timers","title":"3. Use hardware timers","text":"<p>However, as stated in the library documentation, \"The library use no interupts of the hardware timers and works with the micros() / millis() function.\"</p>"},{"location":"microcontrollers_programming/lab3/","title":"Lab Session 3: PWM","text":""},{"location":"microcontrollers_programming/lab3/#lab-session-3-pwm","title":"Lab Session 3: PWM","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"microcontrollers_programming/lab3/#1-title","title":"1. Title","text":""},{"location":"microcontrollers_programming/lab4/","title":"Lab Session 2: Incremental Encoders","text":""},{"location":"microcontrollers_programming/lab4/#lab-session-2-incremental-encoders","title":"Lab Session 2: Incremental Encoders","text":"<p>Estimated time: 1.5h (1 session)</p>"},{"location":"microcontrollers_programming/lab4/#1-title","title":"1. Title","text":""},{"location":"mqtt/","title":"MQTT","text":""},{"location":"mqtt/#mqtt","title":"MQTT","text":"<ul> <li> <p>Getting Started: \"A hands-on introduction to MQTT\".</p> <p>Here you will start working with MQTT.</p> </li> <li> <p>Exercise 1:: \"MQTT with ESP32 in wokwi\".</p> <p>In this exercise you will learn how to develop an IoT application based on MQTT that allows you to publish and subscribe to topics with an ESP32 in simulation from Wokwi.</p> </li> <li> <p>Exercise 2:: \"MQTT with ESP32 in the real world\".</p> <p>Example of MQTT application with a real ESP32.</p> </li> <li> <p>Lab Session:: \"MQTT with M5Core2\".</p> <p>MQTT Lab Exercise with the M5 Core 2 device.</p> </li> </ul>"},{"location":"mqtt/exercise1/","title":"Exercise 1: MQTT with ESP32 in wokwi","text":"<p>This section from the Industrial Informatics Course provides a practical guide to understanding and implementing MQTT with an ESP32 in simulation</p>"},{"location":"mqtt/exercise1/#contents","title":"Contents","text":"<ul> <li> <p>1. Connect to a network via WiFi</p> <ul> <li>How to connect the device to a network.</li> </ul> </li> <li> <p>2. Create a client and connect to a MQTT broker</p> <ul> <li>How to create an ESP32 client and connect it to a MQTT broker.</li> </ul> </li> <li> <p>3. Create a publisher</p> <ul> <li>How to publish messages to a topic with an ESP32 client.</li> </ul> </li> <li> <p>4. Create a subscriber</p> <ul> <li>How to subscribe to a topic to receive messages with an ESP32 client.</li> </ul> </li> <li> <p>5. Exercise: practical application</p> <ul> <li>A simple practical exercise to put practice the knowledge acquired in this part of the course.</li> </ul> </li> </ul> <p>This guide is designed to help learners set up and operate an MQTT broker, forming the foundation for efficient message exchange between IoT devices.</p>"},{"location":"mqtt/exercise1/part1_connect_wifi/","title":"1. Connect to a network via WiFi","text":"<p>In order to develop an IoT application using MQTT with an ESP32, the first thing we need to do is to connect the device to a network. Although this can be done in several ways, the most convenient way is to do it to a WiFi network. </p> <p>Let's do it in Wokwi!</p> <p>Warning</p> <p>As we are working in wokwi remotely, the ESP32 will have to connect to a wifi network accessible from the wokwi servers (i.e., you cannot connect the device to your WiFi network). Wokwi simulates a WiFi network with full internet access and provides a virtual WiFi access point called Wokwi-GUEST. It is an open access point - no password is required. For more info about network access in wokwi, check this link.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> wifi_connect.ino<pre><code>#include &lt;WiFi.h&gt; // (1)!\n\n#define WIFI_SSID \"Wokwi-GUEST\" // (2)!\n#define WIFI_PASSWORD \"\" // (3)!\n#define WIFI_CHANNEL 6 // (4)!\n\nvoid ConnectWiFi() // (5)!\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL); // (6)!\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED) // (7)!\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid setup(void) \n{\n  Serial.begin(115200);\n  ConnectWiFi(); // (8)!\n}\n\nvoid loop()\n{\n  delay(10); // (9)!\n}\n</code></pre> <ol> <li>The ESP32 WiFi library is based on the Arduino WiFi library and enables network connection (local and Internet) via WiFi.</li> <li>Here we define the name of the wifi network to which we want the device to connect. If you want to use the ESP32 in the real world, you need to enter the name of your local network</li> <li>Introduce the password of the network</li> <li>This is required in wokwi only. According to the documentation: We specify the WiFi channel number (6) when calling WiFi.begin(). This skips the WiFi scanning phase and saves about 4 seconds when connecting to the WiFi.</li> <li>This function is used to connect to the WiFi network (you can reuse it in your projects).</li> <li>This method initializes the WiFi library's network settings. If you don't want to use WIFI_CHANNEL (i,e., in real world project), you can delete the third argument of the function.    </li> <li>Wait until the device has connected to the network, when it's connected, it will display it through the serial port.</li> <li>The function <code>ConnectWiFi()</code> is called from the <code>setup()</code> so that the device connects to the network at the beginning of the program.</li> <li>This scripts doesn't do anything else, so there's nothing inside the <code>loop()</code>. Don't forget the <code>delay(10)</code> to speed up the simulation in wokwi (this is not needed in real world applications)</li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to connect an ESP32 to a WiFi network</p>"},{"location":"mqtt/exercise1/part2_client_connect/","title":"2. Create a client and connect to a MQTT broker","text":"<p>Let's extend the code from the previous entry and connect the ESP32 to a broker. </p> <p>Info</p> <p>The ESP32 is a simulated device in wokwi, so you won't be able to use your own broker (see 1. Install Mosquitto) unless you have allowed access to your network over the internet (this wasn't explained in thi course). Hence, let's use use a third party broker: the broker test.mosquitto.org. </p> <p>Public MQTT Broker</p> <p>Be aware that you're going to use a third party broker which is completely open. This implies that, first, you should not share relevant or sensitive information through that broker and use it only to test your MQTT application.</p> <p>Client and Topic names</p> <p>This broker is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_connect.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt; // (1)!\n#include &lt;PubSubClient.h&gt; // (2)!\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"test.mosquitto.org\"; // (3)!\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test\"; // (4)!\n\nWiFiClient espClient; // (5)!\nPubSubClient mqttClient(espClient); // (6)!\n\nvoid ConnectWiFi() // (7)!\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt() // (8)!\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT); \n}\n\nvoid ConnectMqtt() // (9)!\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\"try again in 5 seconds\");\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt() // (10)!\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt(); // (11)!\n}\n\nvoid loop()\n{\n  HandleMqtt(); // (12)!\n  delay(10);\n}\n</code></pre> <ol> <li>WiFiClient allows the creation of a client that can connect to to a specified internet IP address and port. In this case, you will use it to create a client connected to the test.mosquitto.org broker (server).</li> <li>PubSubClient allows a client for doing simple publish/subscribe messaging with a server that supports MQTT.</li> <li>You need to specify the broker address (test.mosquitto.org). If you want to use it with another broker, you need to specify the IP of the broker here (e.g., 192.168.0.12). You need to specify the broker port (by default, 1883 in MQTT).  NOTE THE * !!</li> <li>You need to specify the client name. Don't use a generic name, this name is the one that will be use the broker and other devices of the MQTT network. NOTE THE * !!</li> <li>Create the client. This name is not the client name in the network, but the name of the object in the script. I.e., you can choose the name freely as it won't be seen by anyone. </li> <li>Create the MQTT client.</li> <li>This functions is the same as the one in connect_wifi.</li> <li>This function initializes the client in the MQTT broker (you need to specify the IP address and port of the broker=server). I know there's only one line of code inside the function, it's been done on purpose. You'll see the reason in subscriber.</li> <li>This function connects the client to the broker. If the client isn't connected, it will try to connect every 5 seconds. If the client connects, it'l display it through the serial port.</li> <li>This function handles the connection to the broker. If the connection is lost, it calls the <code>ConnectMqtt()</code> function. If the client is connected, it uses the <code>mqtt.loop()</code> to check for new messages.</li> <li>The function <code>InitMqtt()</code> is called in the <code>setup()</code>.</li> <li>The funcion <code>HandleMqtt()</code> is called in the loop to keep the client connected and constantly check for new messages.</li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> <p>Cannot connect to broker</p> <p>It is possible that you've found problems when connecting to the broker <code>test.mosquitto.org</code>. Keep in mind that this server is public and is used by thousands of people simultaneously, so sometimes it doesn't work properly. Alternatively, you can use other free public brokers (e.g., the one used in the image above: <code>mqtt.eclipseprojects.io</code>).</p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to connect a MQTT client with an ESP32 and connect it to a broker</p>"},{"location":"mqtt/exercise1/part3_publisher/","title":"3. Create a publisher","text":"<p>Let's give some action to our MQTT application. This entry shows how you can create a publisher with an ESP32 in wokwi that can send messages to your PC. </p> <p>Client and Topic names</p> <p>You're going to use a public broker that is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_publisher.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_pub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload; // (1)!\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  // Wait for connection\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.print(\"Client connected\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid PublishMqtt(unsigned long data) // (2)!\n{\n  payload = \"\";\n  payload = String(data);\n  mqttClient.publish(\"/running_time\", (char *)payload.c_str());\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop()\n{\n  HandleMqtt();\n\n  PublishMqtt(millis()); // (3)!\n  Serial.println(millis()); \n\n  delay(1000);\n}\n</code></pre> <ol> <li>The client will publish messages to a topic using the method  <code>publish()</code> from the <code>PubSubClient.h</code> library. Checking the code of that method you will see it publishes <code>char</code> data. Remember the difference between <code>char</code> and <code>String</code>: In C++, the sequence of characters can be stored in two ways: either as a <code>std::string</code> (<code>String</code> in Arduino) object or <code>char array</code>. The latter is an array that contains single characters terminated by a null character, while the former creates an object that is used to represent strings in C++ and contain many methods to help in string manipulation. Since it's easier to manipulate <code>String</code>data than <code>char</code> data, we will use the <code>String</code> object <code>payload</code> to store the message that will be publish. This message, however, will need to be casted to a <code>char</code>before being published with <code>publish()</code> (explained later in the code). </li> <li>This function is used to publish <code>data</code> in a specific topic. It receives the <code>data</code> as a parameter (in this case <code>data</code> is an <code>unsigned long</code> variable, but it could have been something else, e.g., a <code>boolean</code>, or a <code>float</code>). The content of data need to be casted into <code>String</code>: here's when you use the <code>payload</code> variable. Then, the content of <code>payload</code> need to be casted into <code>char</code> according to the specifications of the method <code>publish()</code>. This is done with <code>(char *)payload.c_str()</code>.</li> <li>The function <code>PublishMqtt()</code> is called in the loop every 1s. The running time in milliseconds is given as a parameter to that function, meaning that will be the message to be published. </li> </ol> </li> <li> <p>If you have done it correctly, you should see the following</p> <p></p> <p>Info</p> <p>By checking the topic in MQTT Explorer you can see the time in milliseconds it takes for the ESP32 to publish the message and print over the serial port: 4 ms (it has to run the code inside <code>PublishMqtt()</code>, which also runs the method <code>publish()</code>).</p> </li> <li> <p>Subscribe to the topic in your terminal </p> <p>Run the following command in the terminal and you'll see that the ESP32 is communicating with your PC via MQTT as shwon in the image below </p><pre><code>mosquitto_sub -h mqtt.eclipseprojects.io -t /running_time\n</code></pre> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to publish messages to a MQTT topic with an ESP32.</p>"},{"location":"mqtt/exercise1/part4_subscriber/","title":"4. Create a subscriber","text":"<p>This entry shows how you can create a subscriber with an ESP32 in wokwi that can subscribe to topics. </p> <p>Client and Topic names</p> <p>You're going to use a public broker that is used by many people simultaneously. Hence, you must choose the clients and topics name with this in mind. I.e., avoid using generic names as a <code>test</code> or <code>example</code>. Also, emember that the client name is unique.</p> <ol> <li> <p>Open a new project in wokwi and load the following diagram.json.</p> <p> Show diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": 0,\n      \"left\": 0,\n      \"attrs\": {}\n    }\n  ],\n  \"connections\": [\n    [\n      \"esp:TX\",\n      \"$serialMonitor:RX\",\n      \"\",\n      []\n    ],\n    [\n      \"esp:RX\",\n      \"$serialMonitor:TX\",\n      \"\",\n      []\n    ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> </p> </li> <li> <p>Run the following code</p> client_subscriber.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_sub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload;\nString content = \"\"; // (1)!\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n  SuscribeMqtt(); // (2)!\n  mqttClient.setCallback(OnMqttReceived); // (3)!\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n      SuscribeMqtt(); // (4)!\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid SuscribeMqtt() // (5)!\n{\n  mqttClient.subscribe(\"/testing_topic\");\n}\n\nvoid OnMqttReceived(char *topic, byte *payload, unsigned int length) // (6)!\n{\n  Serial.print(\"Received on \");\n  Serial.print(topic);\n  Serial.print(\": \");\n\n  content = \"\"; \n  for (size_t i = 0; i &lt; length; i++) // (7)!\n  {\n    content.concat((char)payload[i]);\n  }\n  Serial.print(content);\n  Serial.println();\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop() // (8)!\n{\n  HandleMqtt();\n  delay(10);\n}\n</code></pre> <ol> <li>As the message received in the topic will be a <code>char</code>, you'll use this variable to convert it to <code>String</code> for easier manipulation.</li> <li>Now, after setting the server, we need to call the function <code>SubscribeMqtt()</code>. This functions establishes the topics to which the client will be subscribed. This operation is a function for two reasons: <ol> <li>If the client is disconnected, it needs to subscribe to the topics again. So the function can be called multiple times in the code.</li> <li>If there is (or could be in the future) more than one topics to subscribe to, it can be easily addressed by simply modifying the code inside this function.</li> </ol> </li> <li>We need to set the function (callback) that will be called everytime a message is received. This function has been named <code>OnMqttReceived</code>.</li> <li><code>SubscribeMqtt()</code> is called again if the connection to the broker is lost.</li> <li><code>SubscribeMqtt()</code> defines the topics to which the client will subscribe. In this case, it will only subscribe to the topic <code>/testing_topic</code>, but there could be more than one inside the function. The client is subscribed to a topic using the method  <code>subscribe()</code> from the <code>PubSubClient.h</code> library. </li> <li>This function is a callback that will be called everytime a message is published in any of the topics that the client is subscribed to (similar to an interruption). Inside the callback, you get access to the <code>topic</code> where the message was published, the content of the message throught the variable <code>payload</code>, and the <code>length</code> of that message. </li> <li>The content of <code>payload</code> will be casted into <code>String</code>. In this case, <code>payload</code> is an array of bytes. These <code>bytes</code> need to be first casted into characters and then concatenated to form the final <code>String</code>. To do this, we first need to go through all the positions of the array (i.e., we use a <code>for</code> loop). This loop will go from the first element (<code>i=0</code>) to the last one (<code>i=length</code>). In every step of the loop, we first cast the element <code>i</code> of the array <code>payload</code> to <code>char</code>: <code>(char)payload[i]</code>. The data of this element should be concatenated to the string of <code>content</code> to form the final message. To do that we can use the method <code>concat()</code>. When the loop finishes, the <code>content</code> of the message is displayed through the serial port.</li> <li>This client works as a subscriber only. It means it won't do anything until a message is received. Hence, there's nothing inside the <code>loop()</code> (apart from the <code>HandleMqtt()</code> funcion that was explained in a previous entry).  </li> </ol> </li> <li> <p>If you have done it correctly, you should see that the ESP32 prints the content of the messages received in the topic <code>/testing_topic</code>. You can test it from the MQTT Explorer or the terminal.</p> <p></p> </li> </ol> <p>CONGRATULATIONS!</p> <p>Now you're able to subscribe to a MQTT topic with an ESP32.</p>"},{"location":"mqtt/exercise1/part5_exercise/","title":"5. Exercise: practical application","text":"<p>An exercise is proposed to communicate two ESP32s in an MQTT netword. One of them acts as publisher while the other as subscriber. The one that has the role of publisher has a button connected and, when the button is pressed (or released), it publishes in a topic that the button has been pressed. The other ESP32 will have a LED connected and will subscribe to the topic in which the ESP32 publisher publishes. Then, each time it receives a message in the topic, it changes the state of the LED.</p> <p>To test the application you can open two tabs in the browser and check that it works as follows:</p> <p></p> <p>Try to solve the problem before seeing the solution below.</p> Show publisher diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juan M. Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"board-esp32-devkit-c-v4\",\n      \"id\": \"esp\",\n      \"top\": -124.8,\n      \"left\": -187.16,\n      \"attrs\": {}\n    },\n    {\n      \"type\": \"wokwi-pushbutton\",\n      \"id\": \"btn1\",\n      \"top\": -3.4,\n      \"left\": -326.4,\n      \"attrs\": { \"color\": \"green\", \"bounce\": \"0\" }\n    }\n  ],\n  \"connections\": [\n    [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n    [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ],\n    [ \"btn1:1.r\", \"esp:14\", \"green\", [ \"v0\" ] ],\n    [ \"btn1:2.r\", \"esp:GND.1\", \"black\", [ \"h0\" ] ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> Show publisher code mqtt_publisher_button.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n# define BUTTON_PIN 14\n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_pub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload; \n\nvolatile bool button_released = false;\n\n\nvoid IRAM_ATTR buttonReleased(){\n  button_released = true;\n}\n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.print(\"Client connected\");\n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid PublishMqtt(bool data) \n{\n  payload = \"\";\n  payload = String(data);\n  mqttClient.publish(\"/button_released\", (char *)payload.c_str());\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt((BUTTON_PIN)), buttonReleased, FALLING);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop()\n{\n  HandleMqtt();\n\n  if (button_released){\n    PublishMqtt(true);\n    Serial.println(\"Publishing button data\");\n    button_released = false;\n  }\n\n  delay(10);\n}\n</code></pre> Show subscriber diagram.json diagram.json<pre><code>{\n  \"version\": 1,\n  \"author\": \"Juanma Gandarias\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    { \"type\": \"board-esp32-devkit-c-v4\", \"id\": \"esp\", \"top\": -38.4, \"left\": -158.36, \"attrs\": {} },\n    {\n      \"type\": \"wokwi-led\",\n      \"id\": \"led1\",\n      \"top\": -42,\n      \"left\": -274.6,\n      \"attrs\": { \"color\": \"green\" }\n    },\n    {\n      \"type\": \"wokwi-resistor\",\n      \"id\": \"r1\",\n      \"top\": 41.8,\n      \"left\": -288.85,\n      \"rotate\": 270,\n      \"attrs\": { \"value\": \"1000\" }\n    }\n  ],\n  \"connections\": [\n    [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n    [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ],\n    [ \"led1:C\", \"r1:2\", \"black\", [ \"v0\" ] ],\n    [ \"r1:1\", \"esp:GND.1\", \"black\", [ \"v38.4\", \"h105.45\" ] ],\n    [ \"led1:A\", \"esp:26\", \"green\", [ \"v0\" ] ]\n  ],\n  \"dependencies\": {}\n}\n</code></pre> Show subscriber code mqtt_subscriber_LED.ino<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;PubSubClient.h&gt;\n\n#define LED_PIN 26       \n\n#define WIFI_SSID \"Wokwi-GUEST\"\n#define WIFI_PASSWORD \"\"\n#define WIFI_CHANNEL 6\n\nconst char *MQTT_BROKER_ADRESS = \"mqtt.eclipseprojects.io\";\nconst uint16_t MQTT_PORT = 1883;\nconst char *MQTT_CLIENT_NAME = \"ESP32_test_sub\";\n\nWiFiClient espClient;\nPubSubClient mqttClient(espClient);\n\nString payload;\nString content = \"\"; \n\nvoid ConnectWiFi()\n{\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);\n  Serial.print(\"Connecting to WiFi \");\n  Serial.print(WIFI_SSID);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(100);\n    Serial.print(\".\");\n  }\n  Serial.println(\" Connected!\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid InitMqtt()\n{\n  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);\n  SuscribeMqtt(); \n  mqttClient.setCallback(OnMqttReceived); \n}\n\nvoid ConnectMqtt()\n{\n  while (!mqttClient.connected())\n  {\n    Serial.print(\"Starting MQTT connection...\");\n    if (mqttClient.connect(MQTT_CLIENT_NAME))\n    {\n      Serial.println(\"Client connected!\");\n      SuscribeMqtt(); \n    }\n    else\n    {\n      Serial.print(\"Failed MQTT connection, rc=\");\n      Serial.print(mqttClient.state());\n      Serial.println(\" try again in 5 seconds\");\n\n      delay(5000);\n    }\n  }\n}\n\nvoid HandleMqtt()\n{\n  if (!mqttClient.connected())\n  {\n    ConnectMqtt();\n  }\n  mqttClient.loop();\n}\n\nvoid SuscribeMqtt() \n{\n  mqttClient.subscribe(\"/button_released\");\n}\n\nvoid OnMqttReceived(char *topic, byte *payload, unsigned int length) \n{\n  Serial.print(\"Received on \");\n  Serial.print(topic);\n  Serial.print(\": \");\n\n  content = \"\"; \n  for (size_t i = 0; i &lt; length; i++) \n  {\n    content.concat((char)payload[i]);\n  }\n\n  Serial.print(content);\n  Serial.println();\n\n  digitalWrite(LED_PIN, !digitalRead(LED_PIN));\n}\n\nvoid setup(void)\n{\n  Serial.begin(115200);\n  pinMode(LED_PIN, OUTPUT);\n  ConnectWiFi();\n  InitMqtt();\n}\n\nvoid loop() \n{\n  HandleMqtt();\n  delay(10);\n}\n</code></pre>"},{"location":"mqtt/exercise2/","title":"Exercise #2: MQTT with ESP32 in real world","text":"<p>TBD</p>"},{"location":"mqtt/getting_started/","title":"Getting Started: A hands-on introduction to MQTT","text":"<p>This section from the Industrial Informatics Course provides a practical guide to understanding and implementing MQTT (Message Queuing Telemetry Transport), a lightweight messaging protocol widely used in IoT (Internet of Things) applications.</p>"},{"location":"mqtt/getting_started/#contents","title":"Contents","text":"<ul> <li> <p>1. Install Mosquitto</p> <ul> <li>Step-by-step instructions for installing Mosquitto, an open-source MQTT broker, on your system.</li> </ul> </li> <li> <p>2. Testing Mosquitto from the terminal</p> <ul> <li>Guidance on testing the Mosquitto installation using terminal commands to verify its proper operation.</li> </ul> </li> <li> <p>3. Allow External Connections</p> <ul> <li>Steps to configure Mosquitto to accept external client connections, enabling communication over a network.</li> </ul> </li> </ul> <p>This guide is designed to help learners set up and operate an MQTT broker, forming the foundation for efficient message exchange between IoT devices.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/","title":"1. Install Mosquitto","text":""},{"location":"mqtt/getting_started/part1_install_mosquitto/#introduction","title":"Introduction","text":"<p>Eclipse Mosquitto is an Open Source Broker from the Eclipse Foundation distributed under EPL/EDL license that implements MQTT protocol. It is lightweight and is suitable for use on all devices from low power single board computers to full servers. It is programmed in C and is compatible with most OS. The code can be found in this repo.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#installation","title":"Installation","text":"<p>To install Mosquitto, you can follow the next steps.</p> <p>Info</p> <p>\"The steps below outline the Mosquitto installation process for Windows. If you are using Ubuntu, the installation process is much easier. You can find the steps for Ubuntu installation here. </p> <ol> <li>Download the installer from the official website. Check the corresponding type of your processor architecture (most probably 64-bit). Once you have the <code>.exe</code>, execute it to start the installation process.</li> <li>During the installation, install all the components.</li> </ol> <p></p> <ol> <li>When the installer asks you for the Destination Folder, leave the default one (most probably: <code>C:\\Program Files\\mosquitto</code>).</li> </ol> <p></p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#start-mosquitto","title":"Start Mosquitto","text":"<p>Now, you can start mosquitto through windows services. You can open the services by clicking the Win button and typing <code>Services</code>.  Here you can check the multiple ways to open windows services.</p> <p></p> <p>Once you have find the mosquito broker service, you can click on Start the service to start and enable the port where the mosquito will start listening for requests.</p> <p></p> <p>Info</p> <p>It may happen that when you open the windows services, mosquitto is already running.</p> <p>You can check in the terminal (Win <code>cmd</code>) if the service is active and the port enabled with the following command.</p> <pre><code>netstat -an\n</code></pre> <p></p> <p>Then you will see a list of enabling ports. Port 1883 is the one used by mosquitto for communication.</p> <p></p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#firewall","title":"Firewall","text":"<p>As mosquitto requires external communication, it is necessary to enable the windows firewall for incoming and outgoing requests on port 1883 (this way, the firewall does not block the mosquitto service).</p> <p>You need to go to <code>Control panel &gt; Windows defender firewall</code>. Then, go yo <code>advanced setting</code>.</p> <p></p> <p>It will open the Advanced Configuration of Firewall window where you have to look for inbound rules and click on new rule.</p> <ol> <li>The first step is to select the type of rule. In this case it is a port, so select it and click on next.</li> <li>Then, you select the rule for <code>tcp</code> and we write the corresponding port: <code>1883</code>. Click on <code>next</code> and allow all the connections.</li> <li>Apply the rule to all the network profiles and place a name to identify it. Click on finish and the rule will be created.</li> </ol> <p>Now you can create the outbound rule. Click on outbound rule and do the same steps you did before.</p>"},{"location":"mqtt/getting_started/part1_install_mosquitto/#path-environment-variable","title":"Path Environment Variable","text":"<p>Once you have Mosquitto running as a service and the firewall is correctly configured, you need to configure the environment variable.</p> <p>Info</p> <p>This is not strictly required but highly recommended. If you don't do this, you can only run Mosquitto commands in the terminal from the root installation folder <code>C:\\Program Files\\mosquitto</code>. If you add this folder to the Path, then you'll be able to run those commands from any location on your system. </p> <p>You need to acced the <code>environment variables</code> and search for the variable path to place the route <code>Control Panel &gt; System and security &gt; System</code>. </p> <p></p> <p>Then, open the advanced system configuration and click on <code>environment variables</code>.</p> <p></p> <p>Include the path where mosquitto was installed (remember step 3 of installation<code>C:\\Program Files\\mosquitto</code>). </p> <p></p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/","title":"2. Testing Mosquitto from the terminal","text":""},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#testing","title":"Testing","text":"<p>If you have already completed Part 1, now you can test mosquitto broker in your local machine. Open one terminal (Win + <code>cmd</code>) and go to the route where mosquitto was installed</p> <pre><code>cd C:\\Program Files\\mosquitto\n</code></pre> <p>Info</p> <p>If you have already configured the variable path in Part 1, the previous step should not be necessary.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#creating-a-subscriber","title":"Creating a subscriber","text":"<p>This terminal will act as a subscriber and will receive the messages published in the topic <code>/test</code>. To do so, run the following command</p> <pre><code>mosquitto_sub -h localhost -t /test\n</code></pre> <ol> <li> <p><code>mosquitto_sub</code> </p> <ul> <li>This is the Mosquitto client tool used to subscribe to an MQTT topic.</li> <li>It listens for messages published to specific topics.</li> </ul> </li> <li> <p><code>-h localhost</code> </p> <ul> <li><code>-h</code> specifies the host or broker address to connect to.</li> <li><code>localhost</code> means the broker is running on the same machine where the command is being executed. If the broker is on a remote server, you'd need to replace    <code>localhost</code> with the server's IP address or domain name.</li> </ul> </li> <li> <p><code>-t /test</code> </p> <ul> <li><code>-t</code> specifies the topic to subscribe to.</li> <li><code>/test</code> is the topic name in this example. Topics are hierarchical strings used by MQTT brokers to route messages. In this case, the client will subscribe to the <code>/test</code> topic and receive any messages published to it.</li> </ul> </li> </ol>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#explanation","title":"Explanation:","text":"<p>The command subscribes to the MQTT topic <code>/test</code> on a broker running locally (at <code>localhost</code>). Messages sent to the <code>/test</code> topic by other MQTT clients or publishers will be received and displayed by this subscriber.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#creating-a-publisher","title":"Creating a publisher","text":"<p>Without closing that terminal, open another one (Win + <code>cmd</code>). This second terminal will act as a publisher that will publish the message This is a testing message: Hello, MQTT! in the topic <code>/test</code>. This message will be received by the subscriber and will display it in the terminal</p> <pre><code>mosquitto_pub -h localhost -t /test -m \"This is a testing message: Hello, MQTT!\"\n</code></pre> <ol> <li> <p><code>mosquitto_pub</code> </p> <ul> <li>This is the Mosquitto client tool used to publish messages to an MQTT topic.</li> <li>It sends messages to the specified topic on the broker.</li> </ul> </li> <li> <p><code>-h localhost</code> </p> <ul> <li><code>-h</code> specifies the host or broker address to connect to.</li> <li><code>localhost</code> means the broker is running on the same machine where the command is being executed. If the broker is on a remote server, you'd replace <code>localhost</code> with the server's IP address or domain name.</li> </ul> </li> <li> <p><code>-t test</code> </p> <ul> <li><code>-t</code> specifies the topic to which the message will be published.</li> <li><code>test</code> is the topic name in this example. Other MQTT clients subscribed to this topic will receive the message.</li> </ul> </li> <li> <p><code>-m \"This is a testing message: Hello, MQTT!\"</code> </p> <ul> <li><code>-m</code> specifies the message to publish.</li> <li><code>\"This is a testing message: Hello, MQTT!\"</code> is the message content being sent to the <code>test</code> topic. Clients subscribed to the topic will see this exact message.</li> </ul> </li> </ol>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#explanation_1","title":"Explanation:","text":"<p>The command publishes the message <code>\"This is a testing message: Hello, MQTT!\"</code> to the MQTT topic <code>test</code> on a broker running locally (at <code>localhost</code>). Any MQTT clients subscribed to the <code>test</code> topic will receive this message.</p>"},{"location":"mqtt/getting_started/part2_testing_mosquitto_terminal/#expected-result","title":"Expected result","text":"<p>If you have correctly done all the steps, you should have seen the following:</p> <p></p> <p>Note</p> <p>The subscriber will keep running indefinitely, waiting for messages. On the other hand, the publisher runs only once to send a single message. If you want to send more messages, you will need to re-run the entire command each time</p>"},{"location":"mqtt/getting_started/part3_external_connections/","title":"3. Allow External Connections","text":"<p>Connection from an external network</p> <p>This section allows you to connect external devices within a local network to the broker that you have created in Part1. When this section talks about IP address, it refers to the private IP address (i.e., the one assigned by the router that creates the network and that is only accessible by the devices that are on the network). If you want to work with devices outside the network, you need to work with the public IP address (which is unique and visible to everyone). If you would like to configure a broker to allow connections through the internet from external networks, you would have to configure port forwarding on the router (similarly to what you did in Part1 with the windows firewall). This could pose several security risks and would require taking precautions such as using TLS/SSL Encryption or a MQTT Proxy. This is out of the scope of this course, so it will not be explained here.</p>"},{"location":"mqtt/getting_started/part3_external_connections/#1-allow-external-connections","title":"1. Allow External Connections","text":"<p>By default, Mosquitto listens only on <code>localhost</code>. To allow external connections:</p> <ol> <li> <p>Open the Mosquitto configuration file (<code>mosquitto.conf</code>). The file is typically located in:</p> <ul> <li>Linux: <code>/etc/mosquitto/mosquitto.conf</code></li> <li>Windows: Wherever you installed Mosquitto, e.g., <code>C:\\Program Files\\mosquitto\\mosquitto.conf</code></li> </ul> </li> <li> <p>Add or edit the following line to bind Mosquitto to all network interfaces:     </p><pre><code>listener 1883\n</code></pre> <p></p> <ul> <li><code>1883</code> is the default MQTT port. If you want a custom port, specify it here.</li> <li>To restrict it to a specific IP, replace <code>listener 1883</code> with <code>listener 1883 &lt;IP Address&gt;</code>.</li> </ul> </li> <li> <p>Restart the Mosquitto service for changes to take effect:</p> <ul> <li>Linux:     <pre><code>sudo systemctl restart mosquitto\n</code></pre></li> <li>Windows: Restart Mosquitto from the Windows Services </li> </ul> </li> </ol> <p>Warning</p> <p>To edit a file inside <code>C:\\Program Files\\mosquitto\\</code>, you'll need administrator rights. To change the <code>mosquitto.conf</code>file, you can open it with VSCode (or any other text editor, e.g., notepad or gedit) if you open it as administrator.</p> <p></p>"},{"location":"mqtt/getting_started/part3_external_connections/#2-enable-username-and-password-authentication","title":"2. Enable Username and Password Authentication","text":"<ol> <li> <p>Create a password file:  </p> <ul> <li> <p>Linux:</p> <p>Use the <code>mosquitto_passwd</code> utility to generate the password file: </p><pre><code>mosquitto_passwd -c /etc/mosquitto/password &lt;username&gt;\n</code></pre> Replace <code>&lt;username&gt;</code> with your desired username. You will be prompted to enter a password. <p>Example: </p><pre><code>mosquitto_passwd -c /etc/mosquitto/password user1\n</code></pre> <code>-c</code> creates a new password file. If you want to add more users later, use: <pre><code>mosquitto_passwd /etc/mosquitto/password &lt;new-username&gt;\n</code></pre> </li> <li> <p>Windows:</p> <p>Use the <code>mosquitto_passwd</code> utility to generate the password file: </p><pre><code>mosquitto_passwd -c C:\\Program Files\\mosquitto\\password &lt;username&gt;\n</code></pre> Replace <code>&lt;username&gt;</code> with your desired username. You will be prompted to enter a password.  <p>Warning</p> <p>To edit a file inside <code>C:\\Program Files\\mosquitto\\</code>, you'll need administrator rights. If you run the previous command, you'll write in the <code>C:\\Program Files\\mosquitto\\password</code> file. To do so, you can open the terminal as administrator.</p> <p></p> <p>Example: </p><pre><code>mosquitto_passwd -c C:\\Program Files\\mosquitto\\password user1\n</code></pre> <p></p> <p><code>-c</code> creates a new password file. If you want to add more users later, use:</p> <pre><code>mosquitto_passwd C:\\Program Files\\mosquitto\\password &lt;new-username&gt;\n</code></pre> </li> </ul> </li> <li> <p>Update the configuration file to use the password file:</p> <ul> <li> <p>Linux:</p> <p>Open <code>mosquitto.conf</code> and add or edit the following lines: </p><pre><code>allow_anonymous false\npassword_file /etc/mosquitto/passwords\n</code></pre> </li> <li> <p>Windows:</p> <p>Open <code>mosquitto.conf</code> and add or edit the following lines: </p><pre><code>allow_anonymous false\npassword_file C:\\Program Files\\mosquitto\\password\n</code></pre> </li> </ul> <p></p> </li> <li> <p>Restart the Mosquitto service:</p> <ul> <li>Linux:     <pre><code>sudo systemctl restart mosquitto\n</code></pre></li> <li>Windows: Restart as mentioned earlier.</li> </ul> </li> </ol> <p>Warning</p> <p>If you receive this error when you try to restart the Mosquitto service</p> <p></p> <p>you must change the permissions of the <code>password</code> file. </p> <ul> <li>Find the password file in <code>C:/Program Files/mosquitto</code>, right click &gt; properties and go to the security tab. </li> </ul> <p>Check if the SYSTEM group has permissions to modify the file. If it does not, you will have to give them as follows. </p> <ul> <li>Click on Edit and then on Add.  </li> </ul> <p></p> <ul> <li>Add the group SYSTEM and give it permissions to modify the file and click on apply (this is very important).</li> </ul> <p></p> <p>The result should look like this</p> <p></p>"},{"location":"mqtt/getting_started/part3_external_connections/#3-firewall-rules","title":"3. Firewall Rules","text":"<p>If Mosquitto is running on a remote machine, make sure the firewall allows connections to the MQTT port (1883 by default).</p> <ul> <li> <p>Linux (using UFW):     </p><pre><code>sudo ufw allow 1883\n</code></pre> </li> <li> <p>Windows: Open \"Windows Defender Firewall,\" and allow inbound traffic for port 1883.</p> </li> </ul> <p>Note</p> <p>This was already done in Part 1</p>"},{"location":"mqtt/getting_started/part3_external_connections/#4-testing-external-access","title":"4. Testing External Access","text":""},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-a-generic-mqtt-client-mqtt-explorer","title":"Testing from a generic MQTT Client (MQTT Explorer)","text":"<p>You can test the connection from a generic MQTT Client like MQTT Explorer.</p> <ol> <li>Install MQTT Explorer.</li> <li> <p>Check the IP of the broker. Open a terminal and run</p> <ul> <li> <p>Linux </p><pre><code>ipconfig\n</code></pre> </li> <li> <p>Windows:      </p><pre><code>ifconfig\n</code></pre> </li> </ul> <p></p> <p>You need to annotate the IPv4 address. In my case: <code>192.168.0.12</code></p> </li> <li> <p>Launch MQTT Explorer and fill the IP, user and password</p> <p></p> </li> <li> <p>Publish in a topic from MQTT Explorer</p> <p></p> </li> </ol>"},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-another-pc","title":"Testing from another PC","text":"<p>You can test the connection from another PC in the network that has installed mosquitto too:</p> <ol> <li> <p>Subscribe from the broker device:     </p><pre><code>mosquitto_sub -h &lt;server-ip&gt; -t test -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> <li> <p>Publish from an external device:     </p><pre><code>mosquitto_pub -h &lt;server-ip&gt; -t test -m \"This is a message from an external device: Hello, MQTT!\" -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> </ol> <p>Replace <code>&lt;server-ip&gt;</code> with the server's IP address, <code>&lt;username&gt;</code> with your chosen username, and <code>&lt;password&gt;</code> with the associated password.</p>"},{"location":"mqtt/getting_started/part3_external_connections/#testing-from-an-smartphone","title":"Testing from an Smartphone","text":"<p>You can test the connection from a Smartphone in the network that has installed mosquitto too:</p> <ol> <li>Install MyMQTT</li> <li> <p>Connect to the broker</p> <p></p> </li> <li> <p>Subscribe to topic <code>/test</code> and go to the Dashboard</p> <p></p> </li> <li> <p>Publish a message in <code>/test</code>from another device in the newtork (e.g., from a terminal in your PC)      </p><pre><code>mosquitto_pub -h &lt;server-ip&gt; -t test -m \"This is a message from an external device: Hello, MQTT!\" -u &lt;username&gt; -P &lt;password&gt;\n</code></pre> </li> <li> <p>The message should be visible in the MyMQTT Dashboard</p> <p></p> </li> </ol>"},{"location":"mqtt/getting_started/part3_external_connections/#summary-of-key-configuration-file-changes","title":"Summary of Key Configuration File Changes","text":"<pre><code>listener 1883\nallow_anonymous false\npassword_file /etc/mosquitto/passwords.txt\n</code></pre> <p>After completing these steps, Mosquitto will accept external connections (i.e., from external devices, but in the local network) on port 1883, and only users with valid credentials can publish or subscribe.</p> <p>CONGRATULATIONS!</p> <p>You have created your first MQTT local network and are able to communicate devices in the network using this protocol and to monitor the traffic of the network</p>"},{"location":"mqtt/lab1/","title":"Lab Session: MQTT with M5Core2","text":"<p>TBD</p>"},{"location":"real-time_control_systems/","title":"Introduction","text":""},{"location":"real-time_control_systems/#real-time-control-systems","title":"Real-Time Control Systems","text":"<ul> <li> <p>Lab Session 5: Real-Time Control Systems.</p> <p>Here, you will explore the fundamentals of real-time control systems.</p> </li> </ul>"},{"location":"real-time_control_systems/lab5/","title":"Lab Session 5: Real-Time Control Systems","text":""},{"location":"real-time_control_systems/lab5/#lab-session-5-real-time-control-systems","title":"Lab Session 5: Real-Time Control Systems","text":"<p>Estimated time: 3h (2 sessions)</p>"},{"location":"real-time_control_systems/lab5/#1-title","title":"1. Title","text":""},{"location":"real-time_embedded_systems/","title":"Real-Time","text":""},{"location":"real-time_embedded_systems/#real-time-for-embedded-systems","title":"Real-Time for Embedded Systems","text":"<ul> <li> <p>External data acquisition \"Topic 1\".</p> <p>Note 1.</p> </li> <li> <p>Event-driven multi-tasking: \"Topic 2\".</p> <p>Note 2.</p> </li> <li> <p>Lab Session 1: \"RT multi-tasking without OS\".</p> <p>Note 3.</p> </li> <li> <p>Intro to RTOS: \"Topic 3\".</p> <p>Note 2.</p> </li> <li> <p>Lab Session 2: \"Multi-tasking with RTOS\".</p> <p>Note 3.</p> </li> </ul>"},{"location":"real-time_embedded_systems/event-driven/","title":"Event-driven multi-tasking","text":"<p>TBD</p>"},{"location":"real-time_embedded_systems/external_data/","title":"External data acquisition","text":"<p>TBD</p>"},{"location":"real-time_embedded_systems/freeRTOS/","title":"Introduction to RTOS","text":"<p>TBD</p>"},{"location":"real-time_embedded_systems/lab1/","title":"Lab Session: RT multi-tasking without OS","text":"<p>TBD</p>"},{"location":"real-time_embedded_systems/lab2/","title":"Lab Session: Multi-tasking with RTOS","text":"<p>TBD</p>"}]}